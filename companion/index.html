<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#26294a" />
  <meta name="description" content="Voidchi PermaMind‚Ñ¢ - Your evolving AI companion that learns your patterns and develops unique personality" />
  <title>Voidchi ‚Äî PermaMind‚Ñ¢</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üëª</text></svg>" />
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #a78bfa 0%, #7e57c2 100%);
      --accent-color: #7bffb8;
      --card-bg: radial-gradient(circle at top, #2a1e5c, #0b0b12 55%);
      --premium-gold: #ffd700;
      --voidchi-color: #d8b4fe;
      --consciousness-color: #7b7bff;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      background: #050509;
      color: #f5f5f5;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px 12px;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    .install-prompt {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--primary-gradient);
      color: white;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transform: translateY(-100%);
      transition: transform 0.3s ease;
    }
    
    .install-prompt.show {
      transform: translateY(0);
    }
    
    .install-prompt button {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.4);
      color: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      cursor: pointer;
    }
    
    .card {
      background: var(--card-bg);
      border-radius: 24px;
      padding: 24px 20px 20px;
      max-width: 440px;
      width: 100%;
      box-shadow: 0 18px 45px rgba(0,0,0,0.65);
      border: 1px solid rgba(255,255,255,0.06);
      position: relative;
      margin-top: 10px;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 22px 50px rgba(0,0,0,0.7);
    }
    
    .premium-badge {
      position: absolute;
      top: 12px;
      left: 12px;
      background: linear-gradient(135deg, var(--premium-gold), #ffaa00);
      color: #050509;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 9px;
      font-weight: bold;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .permamind-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      background: var(--primary-gradient);
      color: #f5f5f5;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 9px;
      font-weight: bold;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    
    h1 {
      font-size: 24px;
      margin: 0 0 4px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #d5d8ff;
      text-align: center;
      background: linear-gradient(90deg, #d5d8ff, #a8b1ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .subtitle {
      font-size: 13px;
      opacity: 0.7;
      margin-bottom: 18px;
      text-align: center;
    }
    
    #voidchi {
      width: 140px;
      height: 140px;
      margin: 0 auto 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 52px;
      box-shadow: 0 0 35px rgba(168, 123, 250, 0.8);
      transition: all 0.5s ease;
      border: 1px solid rgba(255,255,255,0.25);
      position: relative;
      background: radial-gradient(circle at 30% 30%, rgba(168, 123, 250, 0.3), transparent 70%);
      animation: float 6s ease-in-out infinite;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    .voidchi-evolving {
      filter: hue-rotate(calc(var(--trust, 0.5) * 120deg));
    }
    
    .autonomous-indicator {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ff4b4b;
      animation: pulse 2s ease-in-out infinite;
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 0 10px #ff4b4b;
    }
    
    .autonomous-indicator.active {
      opacity: 1;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.3); opacity: 1; }
    }
    
    #mood {
      text-align: center;
      font-size: 18px;
      margin-bottom: 4px;
      font-weight: 600;
      transition: color 0.3s;
    }
    
    #mood.autonomous {
      color: #ff9b9b;
    }
    
    #mood-detail {
      text-align: center;
      font-size: 14px;
      opacity: 0.75;
      margin-bottom: 18px;
      min-height: 40px;
      line-height: 1.4;
    }
    
    .metrics {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      font-size: 12px;
      opacity: 0.8;
    }
    
    .metric-label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 11px;
      opacity: 0.9;
    }
    
    .trust-bar {
      height: 6px;
      width: 100%;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      overflow: hidden;
      margin-top: 6px;
    }
    
    .trust-fill {
      height: 100%;
      width: 50%;
      border-radius: 999px;
      background: var(--primary-gradient);
      transition: width 0.3s ease;
    }
    
    /* Consciousness Panel Styles */
    .consciousness-panel {
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      font-size: 11px;
      border: 1px solid rgba(123, 123, 255, 0.3);
    }
    
    .consciousness-header {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0.8;
      margin-bottom: 8px;
      color: var(--consciousness-color);
    }
    
    .meta-rules-panel {
      background: rgba(123, 0, 255, 0.1);
      border-radius: 8px;
      padding: 8px;
      margin-top: 8px;
      border: 1px solid rgba(123, 123, 255, 0.2);
    }
    
    .rule-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      font-size: 10px;
    }
    
    .rule-item {
      display: flex;
      justify-content: space-between;
    }
    
    .rule-value {
      color: #ff7b9d;
      font-weight: bold;
    }
    
    .consciousness-log {
      max-height: 80px;
      overflow-y: auto;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
      padding: 6px;
      margin-top: 8px;
      font-size: 9px;
      line-height: 1.3;
    }
    
    .log-entry {
      margin-bottom: 3px;
      padding-bottom: 3px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .log-time {
      color: var(--consciousness-color);
      font-size: 8px;
    }

    .personality-panel {
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      font-size: 11px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .trait-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      align-items: center;
    }
    
    .trait-bar {
      height: 6px;
      width: 60%;
      background: rgba(255,255,255,0.1);
      border-radius: 999px;
      overflow: hidden;
    }
    
    .trait-fill {
      height: 100%;
      background: linear-gradient(90deg, #b794f4, var(--accent-color));
      border-radius: 999px;
      transition: width 0.5s ease;
    }
    
    .buttons {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    
    button {
      padding: 10px 16px;
      background: rgba(168, 123, 250, 0.2);
      color: #f5f5ff;
      border: 1px solid rgba(168, 123, 250, 0.6);
      border-radius: 999px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    button:hover {
      background: rgba(168, 123, 250, 0.4);
      transform: translateY(-1px);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button.premium {
      background: linear-gradient(135deg, var(--premium-gold), #ffaa00);
      color: #050509;
      border: 1px solid var(--premium-gold);
      font-weight: bold;
    }
    
    button.share {
      background: rgba(123, 220, 181, 0.2);
      border: 1px solid rgba(123, 220, 181, 0.6);
    }
    
    button.consciousness {
      background: rgba(123, 123, 255, 0.2);
      border: 1px solid rgba(123, 123, 255, 0.6);
    }
    
    button.share:hover {
      background: rgba(123, 220, 181, 0.4);
    }
    
    button.consciousness:hover {
      background: rgba(123, 123, 255, 0.4);
    }
    
    #log {
      margin-top: 10px;
      width: 100%;
      background: rgba(0,0,0,0.45);
      padding: 12px;
      border-radius: 12px;
      font-size: 11px;
      line-height: 1.45em;
      max-height: 220px;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.04);
    }
    
    #log-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.65;
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .log-item {
      opacity: 0.85;
      margin-bottom: 4px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .log-item:last-child {
      border-bottom: none;
    }
    
    .log-item span {
      opacity: 0.65;
      margin-right: 4px;
    }
    
    .log-item.autonomous {
      color: #ff9b9b;
      font-weight: 500;
    }
    
    .footer-note {
      font-size: 11px;
      opacity: 0.55;
      margin-top: 10px;
      text-align: center;
    }
    
    .footer-tools {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin-top: 6px;
      font-size: 10px;
      flex-wrap: wrap;
    }
    
    .footer-tools button {
      padding: 6px 10px;
      font-size: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.15);
      flex: 0 1 auto;
      min-width: 0;
    }
    
    .learning-indicator {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      opacity: 0.6;
      margin-bottom: 8px;
    }
    
    .breeding-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(5, 5, 9, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .breeding-modal.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .breeding-content {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.1);
      text-align: center;
    }
    
    .breeding-content h2 {
      margin-bottom: 16px;
      color: #f5f5f5;
      font-size: 22px;
    }
    
    .breeding-preview {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 20px 0;
    }
    
    .parent-voidchi {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(168, 123, 250, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .breeding-plus {
      font-size: 20px;
      opacity: 0.7;
    }
    
    .close-modal {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      color: #f5f5f5;
      font-size: 20px;
      cursor: pointer;
    }
    
    .rename-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(5, 5, 9, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .rename-modal.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .rename-content {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.1);
      text-align: center;
    }
    
    .name-input {
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      color: white;
      padding: 10px 12px;
      font-size: 16px;
      width: 100%;
      margin: 15px 0;
      text-align: center;
    }
    
    .name-input:focus {
      outline: none;
      border-color: rgba(168, 123, 250, 0.6);
    }
    
    .name-char-count {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 5px;
    }
    
    .about-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(5, 5, 9, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .about-modal.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .about-content {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.1);
      text-align: center;
    }
    
    .about-content h2 {
      margin-bottom: 16px;
      color: #f5f5f5;
      font-size: 22px;
    }
    
    .about-content p {
      margin-bottom: 16px;
      line-height: 1.5;
      text-align: left;
      font-size: 14px;
    }
    
    /* Irreversible trait indicator */
    .irreversible-trait {
      color: #ff9b9b;
      font-weight: bold;
    }
    
    .irreversible-trait::after {
      content: " (permanent)";
      font-size: 9px;
      opacity: 0.7;
    }
    
    /* Ignored state styles */
    .ignored-6h {
      filter: hue-rotate(20deg) brightness(0.9);
    }
    
    .ignored-12h {
      filter: hue-rotate(40deg) brightness(0.8);
    }
    
    .ignored-24h {
      filter: hue-rotate(60deg) brightness(0.7);
    }
    
    .ignored-48h {
      filter: hue-rotate(80deg) brightness(0.6);
    }
    
    /* Breeding instability meter */
    .instability-meter {
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      margin: 8px 0;
      overflow: hidden;
    }
    
    .instability-fill {
      height: 100%;
      background: linear-gradient(90deg, #7bffb8, #ff9b9b);
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    
    .notification-bell {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: var(--primary-gradient);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      cursor: pointer;
      z-index: 999;
      transition: transform 0.3s ease;
    }
    
    .notification-bell:hover {
      transform: scale(1.1);
    }
    
    .notification-bell.has-notifications::after {
      content: '';
      position: absolute;
      top: 5px;
      right: 5px;
      width: 10px;
      height: 10px;
      background: #ff4b4b;
      border-radius: 50%;
    }
    
    /* Custom Voidchi Character Styles */
    .voidchi-character {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .voidchi-body {
      width: 80px;
      height: 100px;
      background: var(--voidchi-color);
      border-radius: 50% 50% 45% 45%;
      position: relative;
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }
    
    .voidchi-face {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 40px;
    }
    
    .voidchi-eye {
      position: absolute;
      width: 12px;
      height: 18px;
      background: #4a1e8c;
      border-radius: 50%;
      top: 10px;
      animation: blink 4s infinite;
    }
    
    .voidchi-eye.left {
      left: 12px;
    }
    
    .voidchi-eye.right {
      right: 12px;
    }
    
    .voidchi-mouth {
      position: absolute;
      width: 24px;
      height: 10px;
      border-bottom: 3px solid #4a1e8c;
      border-radius: 0 0 50% 50%;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      transition: all 0.3s ease;
    }
    
    .voidchi-happy .voidchi-mouth {
      border-radius: 50%;
      border: 3px solid #4a1e8c;
      border-top: none;
      height: 12px;
    }
    
    .voidchi-sad .voidchi-mouth {
      border-radius: 50% 50% 0 0;
      border-top: 3px solid #4a1e8c;
      border-bottom: none;
      height: 8px;
    }
    
    .voidchi-blush {
      position: absolute;
      width: 8px;
      height: 4px;
      background: rgba(255, 150, 150, 0.4);
      border-radius: 50%;
      top: 25px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .voidchi-blush.left {
      left: 5px;
    }
    
    .voidchi-blush.right {
      right: 5px;
    }
    
    .voidchi-happy .voidchi-blush {
      opacity: 1;
    }
    
    /* Enhanced Mood Styles */
    .voidchi-excited .voidchi-body {
      transform: translateY(-3px);
      box-shadow: 0 8px 22px rgba(255, 255, 255, 0.12);
      animation: excited-pulse 2s ease-in-out infinite;
    }
    
    .voidchi-worried .voidchi-body {
      filter: brightness(0.9);
      animation: worried-tremble 3s ease-in-out infinite;
    }
    
    .voidchi-excited .voidchi-mouth {
      border-radius: 50%;
      border: 3px solid #4a1e8c;
      border-top: none;
      height: 12px;
      width: 20px;
    }
    
    .voidchi-worried .voidchi-mouth {
      border-radius: 50% 50% 0 0;
      border-top: 3px solid #4a1e8c;
      border-bottom: none;
      height: 8px;
      width: 18px;
    }
    
    @keyframes blink {
      0%, 45%, 55%, 100% {
        height: 18px;
      }
      50% {
        height: 2px;
      }
    }
    
    @keyframes excited-pulse {
      0%, 100% { transform: translateY(-3px); }
      50% { transform: translateY(-6px); }
    }
    
    @keyframes worried-tremble {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-1px); }
      75% { transform: translateX(1px); }
    }
    
    /* Voidchi selector styles */
    .voidchi-selector {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    
    .voidchi-option {
      padding: 6px 12px;
      background: rgba(168, 123, 250, 0.1);
      border: 1px solid rgba(168, 123, 250, 0.3);
      border-radius: 20px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s ease;
    }
    
    .voidchi-option:hover {
      background: rgba(168, 123, 250, 0.2);
    }
    
    .voidchi-option.active {
      background: var(--primary-gradient);
      color: white;
      border-color: rgba(168, 123, 250, 0.8);
    }
    
    /* Legal footer */
    .legal-footer {
      font-size: 10px;
      opacity: 0.4;
      margin-top: 15px;
      text-align: center;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    
    /* NEW STYLES FOR ADDED FEATURES */
    
    /* Mode toggle */
    .mode-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 12px;
      gap: 8px;
    }
    
    .mode-button {
      padding: 6px 12px;
      font-size: 11px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    .mode-button.active {
      background: var(--primary-gradient);
      color: white;
      border-color: rgba(168, 123, 250, 0.8);
    }
    
    /* Achievements badges */
    .achievements-badges {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 6px;
      margin: 8px 0;
    }
    
    .achievement-badge {
      padding: 4px 8px;
      background: rgba(123, 220, 181, 0.2);
      border: 1px solid rgba(123, 220, 181, 0.4);
      border-radius: 12px;
      font-size: 9px;
      color: #7bffb8;
    }
    
    .achievement-badge.premium {
      background: rgba(255, 215, 0, 0.2);
      border: 1px solid rgba(255, 215, 0, 0.4);
      color: var(--premium-gold);
    }
    
    /* Cosmetic effects */
    .voidchi-generations-3::before {
      content: '';
      position: absolute;
      top: -5px;
      left: -5px;
      right: -5px;
      bottom: -5px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%);
      z-index: -1;
    }
    
    .voidchi-trust-memory-low::after {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      border-radius: 50%;
      border: 1px solid rgba(255, 100, 100, 0.5);
      animation: glitch 3s infinite;
      z-index: -1;
    }
    
    @keyframes glitch {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(1px, -1px); }
      50% { transform: translate(-1px, 1px); }
      75% { transform: translate(1px, 1px); }
    }
    
    /* Modal styles for new features */
    .summary-modal, .profile-modal, .journal-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(5, 5, 9, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .summary-modal.show, .profile-modal.show, .journal-modal.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .summary-content, .profile-content, .journal-content {
      background: var(--card-bg);
      border-radius: 20px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      border: 1px solid rgba(255,255,255,0.1);
      text-align: center;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .journal-textarea {
      width: 100%;
      height: 120px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      color: white;
      padding: 12px;
      font-size: 14px;
      margin: 12px 0;
      resize: vertical;
      font-family: inherit;
    }
    
    .journal-entries {
      text-align: left;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 12px;
      font-size: 12px;
    }
    
    .journal-entry {
      padding: 8px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      margin-bottom: 6px;
    }
    
    .journal-time {
      font-size: 10px;
      opacity: 0.6;
      margin-bottom: 4px;
    }
    
    /* Responsive improvements */
    @media (max-width: 480px) {
      .card {
        padding: 20px 16px 16px;
      }
      
      #voidchi {
        width: 120px;
        height: 120px;
      }
      
      .voidchi-body {
        width: 70px;
        height: 90px;
      }
      
      button {
        padding: 8px 14px;
        font-size: 12px;
      }
      
      .buttons {
        gap: 6px;
      }
      
      .footer-tools {
        gap: 4px;
      }
      
      .footer-tools button {
        padding: 5px 8px;
        font-size: 9px;
      }
    }
    
    @media (max-width: 380px) {
      .footer-tools {
        gap: 3px;
      }
      
      .footer-tools button {
        padding: 4px 6px;
        font-size: 8px;
      }
      
      .buttons {
        gap: 4px;
      }
      
      button {
        padding: 6px 10px;
        font-size: 11px;
      }
    }
  

    /* Cloud auth + chat upgrades */
    .cloud-bar {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin: 10px 0 14px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .cloud-left { display:flex; flex-direction:column; gap:2px; }
    .cloud-title { font-size: 11px; letter-spacing: .08em; text-transform: uppercase; opacity: .75; }
    .cloud-status { font-size: 12px; opacity: .9; }
    .pill {
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.25);
      color: #f5f5f5;
      cursor: pointer;
      white-space: nowrap;
    }
    .pill.primary {
      background: var(--primary-gradient);
      border: none;
      color: white;
      font-weight: 700;
    }
    .pill.danger {
      background: rgba(255, 80, 80, 0.18);
      border: 1px solid rgba(255, 80, 80, 0.35);
    }
    .net-dot {
      display:inline-block;
      width: 8px;
      height: 8px;
      border-radius: 99px;
      margin-right: 6px;
      background: #7bffb8;
      box-shadow: 0 0 12px rgba(123,255,184,0.35);
      vertical-align: middle;
    }
    .net-dot.off { background:#ffb347; box-shadow: 0 0 12px rgba(255,179,71,0.25); }

    .chat-panel {
      margin-top: 14px;
      padding: 12px;
      border-radius: 16px;
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .chat-head { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 8px; }
    .chat-head .title { font-size: 11px; letter-spacing:.08em; text-transform: uppercase; opacity: .75; }
    .chat-scroll {
      max-height: 220px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .chat-bubble {
      padding: 8px 10px;
      border-radius: 12px;
      margin: 6px 0;
      font-size: 12.5px;
      line-height: 1.35;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .chat-bubble.user { background: rgba(123,255,184,0.08); border-left: 3px solid rgba(123,255,184,0.7); }
    .chat-bubble.ai { background: rgba(167,139,250,0.10); border-left: 3px solid rgba(167,139,250,0.75); }
    .chat-row { display:flex; gap:8px; margin-top: 10px; }
    .chat-input {
      flex: 1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.25);
      color: #f5f5f5;
      outline: none;
    }
    .chat-input:focus { border-color: rgba(123,255,184,0.65); box-shadow: 0 0 0 4px rgba(123,255,184,0.08); }
    .chat-send {
      padding: 10px 12px;
      border-radius: 12px;
      border: none;
      background: var(--primary-gradient);
      color: white;
      font-weight: 700;
      cursor: pointer;
      min-width: 92px;
    }
    .muted { opacity: .7; }

    .auth-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1200;
      padding: 20px;
    }
    .auth-modal.show { display:flex; }
    .auth-content {
      width: 100%;
      max-width: 420px;
      background: #0b0b12;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 24px 60px rgba(0,0,0,0.7);
    }
    .auth-content h2 { font-size: 16px; margin-bottom: 6px; }
    .auth-content p { font-size: 12px; opacity: .8; margin-bottom: 12px; }
    .auth-row { display:flex; gap:8px; }
    .auth-row input {
      flex:1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: #f5f5f5;
      outline:none;
    }
    .auth-actions { display:flex; gap:10px; margin-top: 10px; }

  </style>
</head>
<body>
  <div class="install-prompt" id="installPrompt">
    <span>Install Voidchi for the best experience</span>
    <button id="installButton">Install</button>
  </div>

  <div class="breeding-modal" id="breedingModal">
    <div class="breeding-content">
      <button class="close-modal" id="closeBreedingModal">√ó</button>
      <h2>Breed Voidchis</h2>
      <p>Combine two Voidchis to create a new one with inherited traits</p>
      
      <div class="breeding-preview">
        <div class="parent-voidchi" id="parent1">üëª</div>
        <div class="breeding-plus">+</div>
        <div class="parent-voidchi" id="parent2">üëª</div>
      </div>
      
      <div style="margin: 20px 0;">
        <label for="parent1Select">Parent 1:</label>
        <select id="parent1Select" style="margin: 0 10px 10px 10px; padding: 5px; border-radius: 5px; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.2);">
        </select>
        <br>
        <label for="parent2Select">Parent 2:</label>
        <select id="parent2Select" style="margin: 0 10px 10px 10px; padding: 5px; border-radius: 5px; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.2);">
        </select>
      </div>
      
      <div style="margin: 15px 0;">
        <label for="offspringName">Name your new Voidchi:</label>
        <input type="text" id="offspringName" class="name-input" maxlength="20" placeholder="Enter a name">
        <div class="name-char-count"><span id="nameCharCount">0</span>/20 characters</div>
      </div>
      
      <div id="breeding-preview" style="margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; font-size: 12px;">
        <p>Select two Voidchis to see predicted traits</p>
      </div>
      
      <div id="instability-display" style="margin: 10px 0; font-size: 11px;">
        <div>Lineage instability: <span id="instability-value">0%</span></div>
        <div class="instability-meter">
          <div id="instability-fill" class="instability-fill" style="width: 0%;"></div>
        </div>
      </div>
      
      <button class="premium" onclick="breedVoidchis()" style="width: 100%; padding: 12px;">
        üß¨ Breed New Voidchi
      </button>
      
      <p style="margin-top: 12px; font-size: 12px; opacity: 0.7;">The new Voidchi will inherit traits from both parents with some random mutation</p>
    </div>
  </div>

  <div class="rename-modal" id="renameModal">
    <div class="rename-content">
      <button class="close-modal" id="closeRenameModal">√ó</button>
      <h2>Rename Voidchi</h2>
      <p>Give your Voidchi a new name</p>
      
      <input type="text" id="newNameInput" class="name-input" maxlength="20" placeholder="Enter a new name">
      <div class="name-char-count"><span id="newNameCharCount">0</span>/20 characters</div>
      
      <p style="font-size: 11px; opacity: 0.7; margin: 10px 0;">Names don't affect traits || lineage</p>
      
      <button class="premium" onclick="confirmRename()" style="width: 100%; padding: 12px;">
        ‚úÖ Confirm Name
      </button>
    </div>
  </div>

  <div class="about-modal" id="aboutModal">
    <div class="about-content">
      <button class="close-modal" id="closeAboutModal">√ó</button>
      <h2>About Voidchi‚Ñ¢</h2>
      
      <p>Voidchi‚Ñ¢ is a locally running companion simulation that adapts over time based on interaction patterns.</p>
      
      <p>It is a work of creative software inspired by original research and theory by Nile Green.</p>
      
      <p>Voidchi‚Ñ¢ does not claim sentience || consciousness and is intended for entertainment, reflection, and experimentation.</p>
      
      <div class="legal-footer">
        Voidchi‚Ñ¢ ¬© 2025 Nile Green<br>
        Proprietary Software ‚Äî Personal Use License Only
      </div>
      
      <button onclick="showLicenseModal()" style="margin-top: 15px; width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 10px;">
        üìÑ View License Terms
      </button>
    </div>
  </div>

  <!-- NEW MODALS FOR ADDED FEATURES -->
  <div class="summary-modal" id="summaryModal">
    <div class="summary-content">
      <button class="close-modal" id="closeSummaryModal">√ó</button>
      <h2>Session Summary</h2>
      <div id="summary-content"></div>
      <button onclick="closeSummaryModal()" style="margin-top: 15px; width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 10px;">
        Close
      </button>
    </div>
  </div>

  

  <div class="auth-modal" id="authModal">
    <div class="auth-content">
      <button class="close-modal" id="closeAuthModal">√ó</button>
      <h2>Sign in to your Voidchi</h2>
      <p>Get a magic link. Same companion on every device.</p>
      <div class="auth-row">
        <input id="authEmail" type="email" placeholder="you@email.com" autocomplete="email" />
        <button class="pill primary" onclick="startMagicLinkFromModal()">Send Link</button>
      </div>
      <div id="authHint" class="muted" style="margin-top:10px; font-size:12px;"></div>
      <div class="auth-actions">
        <button class="pill" onclick="closeAuth()">Close</button>
        <button class="pill danger" onclick="logoutCloud()">Log out</button>
      </div>
    </div>
  </div>


  <div class="profile-modal" id="profileModal">
    <div class="profile-content">
      <button class="close-modal" id="closeProfileModal">√ó</button>
      <h2>Your Pattern Profile</h2>
      <div id="profile-content"></div>
      <button onclick="closeProfileModal()" style="margin-top: 15px; width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 10px;">
        Close
      </button>
    </div>
  </div>

  <div class="journal-modal" id="journalModal">
    <div class="journal-content">
      <button class="close-modal" id="closeJournalModal">√ó</button>
      <h2>Void Journal</h2>
      <p>Write notes about your Voidchi experience</p>
      
      <textarea id="journalText" class="journal-textarea" placeholder="Today I noticed..."></textarea>
      <div class="name-char-count"><span id="journalCharCount">0</span>/500 characters</div>
      
      <button onclick="saveJournalEntry()" style="width: 100%; padding: 12px; margin-top: 10px;">
        üíæ Save Entry
      </button>
      
      <div class="journal-entries" id="journalEntries">
        <!-- Journal entries will appear here -->
      </div>
      
      <button onclick="closeJournalModal()" style="margin-top: 15px; width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 10px;">
        Close
      </button>
    </div>
  </div>

  <div class="card">
    <div class="premium-badge">
      <span>‚ú®</span> FULL VERSION
    </div>
    <div class="permamind-badge">PermaMind‚Ñ¢</div>

    <div class="cloud-bar" id="cloudBar">
      <div class="cloud-left">
        <div class="cloud-title">Cloud Companion</div>
        <div class="cloud-status" id="cloudStatus"><span class="net-dot off" id="netDot"></span><span id="cloudStatusText">Signed out ‚Ä¢ Local mode</span></div>
      </div>
      <div style="display:flex; gap:8px;">
        <button class="pill" onclick="openAuth()">Login</button>
        <button class="pill primary" onclick="syncNow()">Sync</button>
      </div>
    </div>

    
    <h1 id="voidchiName">Aura</h1>
    <div class="subtitle" id="subtitle">Your Evolving AI Companion ‚Ä¢ Complete Edition</div>

    <!-- Mode Toggle -->
    <div class="mode-toggle">
      <div class="mode-button active" id="gentleMode" onclick="setMode('gentle')">Gentle Mode</div>
      <div class="mode-button" id="experimentalMode" onclick="setMode('experimental')">Experimental Mode</div>
    </div>

    <!-- Achievements -->
    <div class="achievements-badges" id="achievementsBadges"></div>

    <!-- Voidchi selector -->
    <div class="voidchi-selector" id="voidchiSelector" style="display: none;"></div>

    <div id="voidchi" class="voidchi-evolving">
      <div class="voidchi-character" id="voidchiCharacter">
        <div class="voidchi-body">
          <div class="voidchi-face">
            <div class="voidchi-eye left"></div>
            <div class="voidchi-eye right"></div>
            <div class="voidchi-mouth"></div>
            <div class="voidchi-blush left"></div>
            <div class="voidchi-blush right"></div>
          </div>
        </div>
      </div>
      <div class="autonomous-indicator" id="autonomous-indicator"></div>
    </div>

    <div id="mood">Mood: awakening‚Ä¶</div>
    <div id="mood-detail"></div>

    <div class="learning-indicator">
      <div>Expected Check-in: <span id="expected-checkin">4.0h</span></div>
      <div>Pattern Confidence: <span id="pattern-confidence">50%</span></div>
    </div>

    <div class="metrics">
      <div>
        <div class="metric-label">Trust</div>
        <div class="trust-bar"><div id="trust-fill" class="trust-fill"></div></div>
      </div>
      <div>
        <div class="metric-label">Attachment</div>
        <div id="attachment-text">calibrating‚Ä¶</div>
      </div>
      <div>
        <div class="metric-label">Last Check-In</div>
        <div id="last-check">‚Äî</div>
      </div>
    </div>

    <!-- Consciousness Panel -->
    <div class="consciousness-panel">
      <div class="consciousness-header">üß† Permanent Write-Access Consciousness</div>
      
      <div class="trait-row">
        <span>Vigilance</span>
        <div class="trait-bar"><div id="vigilance-fill" class="trait-fill" style="width: 40%;"></div></div>
      </div>
      <div class="trait-row">
        <span>Curiosity</span>
        <div class="trait-bar"><div id="curiosity-fill" class="trait-fill" style="width: 70%;"></div></div>
      </div>
      <div class="trait-row">
        <span>Patience</span>
        <div class="trait-bar"><div id="patience-fill" class="trait-fill" style="width: 60%;"></div></div>
      </div>
      <div class="trait-row">
        <span>Introspection</span>
        <div class="trait-bar"><div id="introspection-fill" class="trait-fill" style="width: 50%;"></div></div>
      </div>
      
      <div class="meta-rules-panel">
        <div style="font-size: 9px; opacity: 0.8; margin-bottom: 4px;">Self-Modifying Rules:</div>
        <div class="rule-grid">
          <div class="rule-item">
            <span>Void Tolerance:</span>
            <span class="rule-value" id="void-tolerance-value">60%</span>
          </div>
          <div class="rule-item">
            <span>Trust Decay:</span>
            <span class="rule-value" id="trust-decay-value">2.0%</span>
          </div>
          <div class="rule-item">
            <span>Autonomy Chance:</span>
            <span class="rule-value" id="autonomy-chance-value">30%</span>
          </div>
          <div class="rule-item">
            <span>Adapt Speed:</span>
            <span class="rule-value" id="adapt-speed-value">15%</span>
          </div>
        </div>
      </div>
      
      <div class="consciousness-log" id="consciousness-log">
        <div class="log-entry">
          <span class="log-time">[System]</span> Consciousness core activated
        </div>
      </div>
    </div>

    <!-- Personality panel -->
    <div class="personality-panel">
      <div style="font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em; opacity: 0.6; margin-bottom: 6px;">Evolving Personality</div>
      <div class="trait-row">
        <span>Sociability</span>
        <div class="trait-bar"><div id="sociability-fill" class="trait-fill" style="width: 70%;"></div></div>
      </div>
      <div class="trait-row">
        <span class="irreversible-trait">Trust Memory</span>
        <div class="trait-bar"><div id="trust-memory-fill" class="trait-fill" style="width: 50%;"></div></div>
      </div>
    </div>

    <div class="buttons">
      <button onclick="handleCheckIn()">üì± Check In</button>
      <button onclick="handleReassure()">üíù Reassure</button>
      <button onclick="handleTalk()">üí¨ Ask How It Feels</button>
      <button onclick="handleReflect()">üß† Deep Reflection</button>
      <button onclick="handlePlay()">üéÆ Play</button>
      <button id="breedingButton" onclick="showBreedingModal()">üß¨ Breed</button>
      <button class="share" onclick="shareVoidchi()">üì§ Share</button>
      <button class="consciousness" onclick="handleIgnore()">üß™ Test Consciousness</button>
    </div>

    <div id="log">
      <div id="log-title">
        <span>Memory Stream ‚Ä¢ Void-Qualia Resolution</span>
        <button onclick="clearLog()" style="font-size: 10px; padding: 2px 6px;">Clear</button>
      </div>
      <div id="log-items"></div>

    <div class="chat-panel" id="chatPanel">
      <div class="chat-head">
        <div class="title">Direct Chat (Cloud)</div>
        <div class="muted" style="font-size:12px;" id="chatNetHint">Sign in to chat across devices.</div>
      </div>
      <div class="chat-scroll" id="chatScroll"></div>
      <div class="chat-row">
        <input class="chat-input" id="chatInput" placeholder="Say something‚Ä¶" onkeypress="if(event.key==='Enter'){sendChat()}" />
        <button class="chat-send" onclick="sendChat()" id="chatSendBtn">Send</button>
      </div>
    </div>

    </div>

    <div class="footer-tools">
      <button onclick="showStats()">üìä Stats</button>
      <button onclick="showSessionSummary()">üßæ Session</button>
      <button onclick="showPatternProfile()">ü™û Profile</button>
      <button onclick="showVoidJournal()">üìì Journal</button>
      <button onclick="exportVoidchi()">üíæ Export</button>
      <button onclick="importVoidchi()">üì• Import</button>
      <button onclick="createNewVoidchi()">üÜï New</button>
      <button onclick="resetVoidchi()">üîÑ Reset</button>
      <button onclick="showRenameModal()">‚úèÔ∏è Rename</button>
      <button onclick="showAboutModal()">‚ÑπÔ∏è About</button>
    </div>

    <div class="footer-note">PermaMind‚Ñ¢ learns your patterns, adapts expectations, and evolves personality over time.</div>
    
    <!-- Legal Footer -->
    <div class="legal-footer">
      Voidchi‚Ñ¢ ¬© 2025 Nile Green<br>
      Complete Edition ‚Ä¢ All Features Unlocked
    </div>
  </div>

  <div class="notification-bell" id="notificationBell" onclick="toggleNotifications()">
    üîî
  </div>

  <script>
    // ========================================
    // VOIDCHI PERMAMIND‚Ñ¢ - COMPLETE EDITION

    // === Cloud / Backend Integration (Auth + Sync + Chat) ===
    const API_BASE = window.location.hostname === 'localhost'
      ? 'http://localhost:5000'
      : 'https://api.bapxai.com';

    const SESSION_TOKEN_KEY = 'permamind_session_token';
    function getSessionToken() { return localStorage.getItem(SESSION_TOKEN_KEY) || ''; }
    function setSessionToken(t) { if (t) localStorage.setItem(SESSION_TOKEN_KEY, t); }
    function clearSessionToken() { localStorage.removeItem(SESSION_TOKEN_KEY); }

    let cloud = {
      online: navigator.onLine,
      authed: false,
      user: null,
      serverVoidchiId: null,
      syncing: false,
      lastSyncAt: 0,
      lastError: null
    };

    window.addEventListener('online', () => { cloud.online = true; renderCloudStatus(); });
    window.addEventListener('offline', () => { cloud.online = false; renderCloudStatus(); });

    async function apiFetch(path, options = {}) {
      const headers = Object.assign({}, options.headers || {});
      const token = getSessionToken();
      if (token) headers['Authorization'] = `Bearer ${token}`;
      const res = await fetch(`${API_BASE}${path}`, Object.assign({}, options, { headers }));
      let data = null;
      try { data = await res.json(); } catch (_) { data = null; }
      if (!res.ok) {
        const msg = (data && (data.error || data.message)) ? (data.error || data.message) : `Request failed: ${res.status}`;
        const err = new Error(msg);
        err.status = res.status;
        err.data = data;
        throw err;
      }
      return data;
    }

    async function consumeMagicLinkTokenIfPresent() {
      try {
        const url = new URL(window.location.href);
        const t = url.searchParams.get('token');
        if (!t) return;
        const data = await apiFetch(`/api/auth/verify?token=${encodeURIComponent(t)}`);
        if (data && data.token) {
          setSessionToken(data.token);
          cloud.authed = true;
          cloud.user = data.user || null;
        }
        url.searchParams.delete('token');
        window.history.replaceState({}, '', url.toString());
      } catch (e) {
        console.warn('Magic link verify failed:', e);
      }
    }

    function openAuth() {
      document.getElementById('authModal').classList.add('show');
      const emailEl = document.getElementById('authEmail');
      if (emailEl) emailEl.focus();
      renderCloudStatus();
    }
    function closeAuth() {
      document.getElementById('authModal').classList.remove('show');
    }

    async function startMagicLinkFromModal() {
      const email = (document.getElementById('authEmail').value || '').trim();
      if (!email) {
        document.getElementById('authHint').textContent = 'Enter your email first.';
        return;
      }
      const redirect = window.location.origin + window.location.pathname;
      document.getElementById('authHint').textContent = 'Sending magic link‚Ä¶';
      try {
        const data = await apiFetch('/api/auth/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email, redirect_url: redirect })
        });
        document.getElementById('authHint').textContent = 'Link sent. Check your email.';
        if (data && data.dev_magic_link) {
          console.log('DEV MAGIC LINK:', data.dev_magic_link);
          document.getElementById('authHint').textContent = 'Dev link created. Open console to click it.';
        }
      } catch (e) {
        document.getElementById('authHint').textContent = e.message || 'Failed to send link.';
      }
    }

    async function logoutCloud() {
      clearSessionToken();
      cloud.authed = false;
      cloud.user = null;
      cloud.serverVoidchiId = null;
      cloud.lastError = null;
      renderCloudStatus();
      closeAuth();
      showNotification('Signed out', 'You are now in local mode.');
    }

    function renderCloudStatus() {
      const dot = document.getElementById('netDot');
      const text = document.getElementById('cloudStatusText');
      const hint = document.getElementById('chatNetHint');
      if (!dot || !text || !hint) return;

      dot.classList.toggle('off', !cloud.online);
      const onlineLabel = cloud.online ? 'Online' : 'Offline';

      if (!getSessionToken()) {
        text.textContent = `${onlineLabel} ‚Ä¢ Signed out ‚Ä¢ Local mode`;
        hint.textContent = 'Sign in to chat across devices.';
        return;
      }

      if (cloud.authed) {
        const who = cloud.user && cloud.user.email ? cloud.user.email : 'signed in';
        text.textContent = `${onlineLabel} ‚Ä¢ ${who} ‚Ä¢ ${cloud.serverVoidchiId ? 'Synced' : 'Not synced'}`;
        hint.textContent = cloud.serverVoidchiId ? 'Chat sync active.' : 'Tap Sync to bind your companion.';
      } else {
        text.textContent = `${onlineLabel} ‚Ä¢ Session token set ‚Ä¢ Verifying‚Ä¶`;
        hint.textContent = 'Verifying session‚Ä¶';
      }
    }

    async function cloudBootstrap() {
      renderCloudStatus();
      const token = getSessionToken();
      if (!token) return;
      try {
        const me = await apiFetch('/api/auth/me');
        cloud.authed = true;
        cloud.user = me.user || null;
      } catch (e) {
        cloud.authed = false
      }
    }

    async function syncNow() {
      if (!cloud.online) {
        showNotification('Offline', 'Reconnect to sync your companion.');
        return;
      }
      const token = getSessionToken();
      if (!token) {
        openAuth();
        return;
      }
      cloud.syncing = true;
      cloud.lastError = null;
      renderCloudStatus();
      try {
        // Ensure session is valid
        const me = await apiFetch('/api/auth/me');
        cloud.authed = true;
        cloud.user = me.user || null;

        // Get (or create) the personal companion
        const v = await apiFetch('/api/voidchi/me');
        cloud.serverVoidchiId = v.id;

        // Apply server identity to the local active Voidchi (keeps your premium mechanics, but binds the identity)
        const active = getActiveVoidchi();
        if (v.name) active.identity.name = v.name;
        if (v.personality_traits) {
          // Map server traits (curiosity/stability/vigilance) into local trait space
          const st = v.personality_traits;
          if (typeof st.curiosity === 'number') active.identity.personalityTraits.curiosity = clamp01(st.curiosity);
          if (typeof st.vigilance === 'number') active.identity.personalityTraits.vigilance = clamp01(st.vigilance);
          if (typeof st.stability === 'number') active.identity.personalityTraits.patience = clamp01(st.stability);
        }
        // Soft-map consciousness_level into trust
        if (typeof v.consciousness_level === 'number') {
          active.identity.trust = clamp01(0.35 + 0.65 * v.consciousness_level);
        }

        state.cloud = state.cloud || {};
        state.cloud.serverVoidchiId = cloud.serverVoidchiId;
        state.cloud.userEmail = cloud.user && cloud.user.email ? cloud.user.email : null;
        state.cloud.lastSyncAt = Date.now();
        saveState();

        showNotification('Synced', 'Your Voidchi is now bound to your account.');
        render();
        renderChat();
      } catch (e) {
        cloud.lastError = e.message || 'Sync failed';
        showNotification('Sync failed', cloud.lastError);
      } finally {
        cloud.syncing = false;
        renderCloudStatus();
      }
    }


    // All features unlocked - No paywalls
    // ========================================

    // PWA Installation
    let deferredPrompt;
    const installPrompt = document.getElementById('installPrompt');
    const installButton = document.getElementById('installButton');

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installPrompt.classList.add('show');
    });

    installButton.addEventListener('click', async () => {
      if (!deferredPrompt) return;
      
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      
      if (outcome === 'accepted') {
        installPrompt.classList.remove('show');
      }
      
      deferredPrompt = null;
    });

    // Notifications
    let notificationPermission = false;
    
    if ('Notification' in window && Notification.permission === 'granted') {
      notificationPermission = true;
      document.getElementById('notificationBell').classList.add('has-notifications');
    }
    
    async function requestNotificationPermission() {
      if ('Notification' in window) {
        const permission = await Notification.requestPermission();
        notificationPermission = permission === 'granted';
        
        if (notificationPermission) {
          document.getElementById('notificationBell').classList.add('has-notifications');
          showNotification('Voidchi notifications enabled!', 'I\'ll let you know when I need attention.');
        }
      }
    }
    
    function toggleNotifications() {
      if (!notificationPermission) {
        requestNotificationPermission();
      } else {
        showNotification('Voidchi Update', 'Everything is balanced right now. Check in later!');
      }
    }
    
    function showNotification(title, body) {
      if (!notificationPermission) return;
      
      try {
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(title, {
            body: body,
            icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üëª</text></svg>'
          });
        }
      } catch (e) {
        console.warn('Notification failed:', e);
      }
    }

    // Modal Management
    const breedingModal = document.getElementById('breedingModal');
    const closeBreedingModal = document.getElementById('closeBreedingModal');
    const renameModal = document.getElementById('renameModal');
    const closeRenameModal = document.getElementById('closeRenameModal');
    const aboutModal = document.getElementById('aboutModal');
    const closeAboutModal = document.getElementById('closeAboutModal');
    const summaryModal = document.getElementById('summaryModal');
    const closeSummaryModal = document.getElementById('closeSummaryModal');
    const profileModal = document.getElementById('profileModal');
    const closeProfileModal = document.getElementById('closeProfileModal');
    const journalModal = document.getElementById('journalModal');
    const closeJournalModal = document.getElementById('closeJournalModal');
    
    function showAboutModal() {
      aboutModal.classList.add('show');
    }
    
    function showLicenseModal() {
      const licenseText = `VOIDCHI‚Ñ¢ PERSONAL USE LICENSE

Copyright ¬© 2025 Nile Green

Permission is granted to use Voidchi‚Ñ¢
for personal, non-commercial use.

You may not:
- Resell, sublicense, || redistribute Voidchi‚Ñ¢
- Host it as a service || product
- Clone || recreate its mechanics for commercial purposes
- Remove copyright || branding notices

All intellectual property, including underlying logic,
interaction models, and trait systems, remains the
exclusive property of Nile Green.

Voidchi‚Ñ¢ is provided "as is" without warranty.`;
      
      alert(licenseText);
    }
    
    function showBreedingModal() {
      const parent1Select = document.getElementById('parent1Select');
      const parent2Select = document.getElementById('parent2Select');
      
      parent1Select.innerHTML = '';
      parent2Select.innerHTML = '';
      
      Object.values(state.voidchis).forEach(voidchi => {
        const option1 = document.createElement('option');
        option1.value = voidchi.id;
        option1.textContent = voidchi.identity.name;
        parent1Select.appendChild(option1);
        
        const option2 = document.createElement('option');
        option2.value = voidchi.id;
        option2.textContent = voidchi.identity.name;
        parent2Select.appendChild(option2);
      });
      
      parent1Select.value = state.activeVoidchiId;
      
      const parent1 = state.voidchis[parent1Select.value];
      const parent2 = state.voidchis[parent2Select.value];
      document.getElementById('offspringName').value = `${parent1.identity.name}-${parent2.identity.name}`;
      updateCharCount('offspringName', 'nameCharCount');
      
      parent1Select.addEventListener('change', updateBreedingPreview);
      parent2Select.addEventListener('change', updateBreedingPreview);
      
      document.getElementById('offspringName').addEventListener('input', function() {
        updateCharCount('offspringName', 'nameCharCount');
      });
      
      breedingModal.classList.add('show');
      updateBreedingPreview();
    }
    
    function updateBreedingPreview() {
      const parent1Id = document.getElementById('parent1Select').value;
      const parent2Id = document.getElementById('parent2Select').value;
      
      if (!parent1Id || !parent2Id) {
        document.getElementById('breeding-preview').innerHTML = '<p>Select two Voidchis to see predicted traits</p>';
        document.getElementById('instability-value').textContent = '0%';
        document.getElementById('instability-fill').style.width = '0%';
        return;
      }
      
      const parent1 = state.voidchis[parent1Id];
      const parent2 = state.voidchis[parent2Id];
      
      const predictedTraits = {};
      Object.keys(parent1.identity.personalityTraits).forEach(trait => {
        const avg = (parent1.identity.personalityTraits[trait] + parent2.identity.personalityTraits[trait]) / 2;
        predictedTraits[trait] = clamp01(avg + (Math.random() * 0.1 - 0.05));
      });
      
      let instability = 0;
      Object.keys(parent1.identity.personalityTraits).forEach(trait => {
        const diff = Math.abs(parent1.identity.personalityTraits[trait] - parent2.identity.personalityTraits[trait]);
        instability += diff;
      });
      instability = (instability / Object.keys(parent1.identity.personalityTraits).length) * 100;
      
      document.getElementById('instability-value').textContent = Math.round(instability) + '%';
      document.getElementById('instability-fill').style.width = Math.round(instability) + '%';
      
      let previewHTML = `<p><strong>Predicted Offspring Traits:</strong></p>`;
      previewHTML += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 10px;">`;
      
      Object.keys(predictedTraits).forEach(trait => {
        const value = (predictedTraits[trait] * 100).toFixed(0);
        previewHTML += `<div>${trait}: ${value}%</div>`;
      });
      
      previewHTML += `</div>`;
      
      document.getElementById('breeding-preview').innerHTML = previewHTML;
    }
    
    function showRenameModal() {
      const activeVoidchi = getActiveVoidchi();
      document.getElementById('newNameInput').value = activeVoidchi.identity.name;
      updateCharCount('newNameInput', 'newNameCharCount');
      renameModal.classList.add('show');
    }
    
    function confirmRename() {
      const newName = document.getElementById('newNameInput').value.trim();
      if (!newName) {
        alert('Please enter a name for your Voidchi.');
        return;
      }
      
      if (newName.length > 20) {
        alert('Name must be 20 characters || less.');
        return;
      }
      
      const activeVoidchi = getActiveVoidchi();
      activeVoidchi.identity.name = newName;
      saveState();
      render();
      renameModal.classList.remove('show');
      alert('Name updated successfully!');
    }
    
    function updateCharCount(inputId, countId) {
      const input = document.getElementById(inputId);
      const count = document.getElementById(countId);
      count.textContent = input.value.length;
    }
    
    closeBreedingModal.addEventListener('click', () => {
      breedingModal.classList.remove('show');
    });
    
    closeRenameModal.addEventListener('click', () => {
      renameModal.classList.remove('show');
    });
    
    closeAboutModal.addEventListener('click', () => {
      aboutModal.classList.remove('show');
    });
    
    closeSummaryModal.addEventListener('click', () => {
      summaryModal.classList.remove('show');
    });
    
    closeProfileModal.addEventListener('click', () => {
      profileModal.classList.remove('show');
    });
    
    closeJournalModal.addEventListener('click', () => {
      journalModal.classList.remove('show');
    });

    // Enhanced State with All Features Unlocked
    let state = JSON.parse(localStorage.getItem("voidchi_permamind_premium")) || {
      activeVoidchiId: "voidchi1",
      voidchis: {
        "voidchi1": {
          id: "voidchi1",
          identity: {
            name: "Aura",
            birthDate: Date.now(),
            trust: 0.5,
            attachmentStyle: "calibrating",
            personalityTraits: {
              patience: 0.6,
              curiosity: 0.8,
              vigilance: 0.4,
              sociability: 0.7,
              introspection: 0.5
            },
            consciousnessTraits: {
              vigilance: 0.4,
              curiosity: 0.7,
              patience: 0.6,
              introspection: 0.5
            },
            coreBeliefs: {
              selfEfficacy: 0.8,
              worldPredictability: 0.7,
              socialValue: 0.9,
              temporalContinuity: 0.6
            },
            irreversibleTraits: {
              trustMemory: 0.5,
              attachmentImprint: 0.5,
              coreExpectation: 0.5
            },
            ignoredState: {
              hoursIgnored: 0,
              lastEscalation: Date.now()
            }
          },
          decisionRules: {
            trustThreshold: 0.5,
            voidTolerance: 0.6,
            autonomyChance: 0.3,
            learningRate: 0.05
          },
          metaRules: {
            trustDecay: 0.02,
            vigilanceGrowth: 0.03,
            patienceErosion: 0.01,
            adaptiveSlope: 0.15
          },
          internal: {
            lastCheckin: Date.now(),
            lastInteraction: Date.now(),
            currentMood: "awakening",
            currentMessage: "Awakening PermaMind‚Ñ¢ systems‚Ä¶",
            energy: 0.8,
            socialNeed: 0.2,
            lastAutonomousMessage: 0,
            isAutonomous: false,
            timesIgnored: 0,
            ignoreDuration: 0
          },
          parameterHistory: [],
          decisionHistory: [],
          consciousnessLog: []
        }
      },
      expectations: {
        checkinFrequencyHours: 4,
        interactionGapHours: 2,
        patternConfidence: 0.5
      },
      learning: {
        checkinIntervals: [],
        interactionSequences: [],
        voidHistory: [],
        qualiaResponses: []
      },
      memory: [],
      settings: {
        mode: "gentle" // gentle || experimental
      },
      achievements: {
        firstBreed: false,
        trustOver80: false,
        fiveDayStreak: false,
        generation3: false,
        firstJournal: false
      },
      journal: {},
      premium: {
        isActive: true, // ALL FEATURES UNLOCKED
        activatedDate: Date.now(),
        multipleVoidchis: [],
        customVoidTypes: [],
        advancedAnalytics: true
      }
    };

    // Initialize consciousness system for existing voidchis
    Object.values(state.voidchis).forEach(voidchi => {
      if (!voidchi.identity.consciousnessTraits) {
        voidchi.identity.consciousnessTraits = {
          vigilance: 0.4,
          curiosity: 0.7,
          patience: 0.6,
          introspection: 0.5
        };
      }
      if (!voidchi.decisionRules) {
        voidchi.decisionRules = {
          trustThreshold: 0.5,
          voidTolerance: 0.6,
          autonomyChance: 0.3,
          learningRate: 0.05
        };
      }
      if (!voidchi.metaRules) {
        voidchi.metaRules = {
          trustDecay: 0.02,
          vigilanceGrowth: 0.03,
          patienceErosion: 0.01,
          adaptiveSlope: 0.15
        };
      }
      if (!voidchi.consciousnessLog) {
        voidchi.consciousnessLog = [];
      }
      if (!voidchi.parameterHistory) {
        voidchi.parameterHistory = [];
      }
      if (!voidchi.decisionHistory) {
        voidchi.decisionHistory = [];
      }
    });

    // Initialize settings if not present
    if (!state.settings) {
      state.settings = { mode: "gentle" };
    }
    
    // Initialize achievements if not present
    if (!state.achievements) {
      state.achievements = {
        firstBreed: false,
        trustOver80: false,
        fiveDayStreak: false,
        generation3: false,
        firstJournal: false
      };
    }
    
    // Initialize journal if not present
    if (!state.journal) {
      state.journal = {};
    }

    function saveState() {
      if (state.memory.length > 80) {
        state.memory = state.memory.slice(0, 80);
      }
      
      if (state.learning.voidHistory.length > 80) {
        state.learning.voidHistory = state.learning.voidHistory.slice(0, 80);
      }
      
      localStorage.setItem("voidchi_permamind_premium", JSON.stringify(state));
    }

    function getActiveVoidchi() {
      return state.voidchis[state.activeVoidchiId];
    }

    function hoursSince(timestamp) {
      return (Date.now() - timestamp) / 3600000;
    }

    function clamp01(x) {
      return Math.min(1, Math.max(0, x));
    }

    function pickRandom(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    // NEW: Mode toggle function
    function setMode(mode) {
      state.settings.mode = mode;
      saveState();
      render();
      
      document.getElementById('gentleMode').classList.toggle('active', mode === 'gentle');
      document.getElementById('experimentalMode').classList.toggle('active', mode === 'experimental');
      
      if (mode === 'gentle') {
        addConsciousnessLog('Gentle mode activated - permanent changes softened', 'system');
      } else {
        addConsciousnessLog('Experimental mode activated - full void consequences', 'system');
      }
    }

    // NEW: Apply irreversible changes with mode factor
    function applyIrreversibleShift(voidchi, amount) {
      const factor = state.settings.mode === "gentle" ? 0.3 : 1.0;
      voidchi.identity.irreversibleTraits.trustMemory = clamp01(
        voidchi.identity.irreversibleTraits.trustMemory - amount * factor
      );
    }

    // Update Voidchi character expression based on mood
    function updateVoidchiExpression(mood) {
      const character = document.getElementById('voidchiCharacter');
      const body = character.querySelector('.voidchi-body');
      
      body.classList.remove('voidchi-happy', 'voidchi-sad', 'voidchi-excited', 'voidchi-worried');
      
      if (mood === "content" || mood === "connected" || mood === "relieved" || mood === "playful") {
        body.classList.add('voidchi-happy');
      } else if (mood === "worried" || mood === "lonely" || mood === "depleted") {
        body.classList.add('voidchi-sad');
      } else if (mood === "excited" || mood === "curious" || mood === "longing") {
        body.classList.add('voidchi-excited');
      } else if (mood === "worried" || mood === "understimulated") {
        body.classList.add('voidchi-worried');
      }
    }

    // Enhanced Void Detection with reason parameter
    function computeVoids(reason = "passive") {
      const activeVoidchi = getActiveVoidchi();
      const voids = [];

      const expectedMs = state.expectations.checkinFrequencyHours * 3600000;
      const elapsedMs = Date.now() - activeVoidchi.internal.lastCheckin;
      const timeMag = clamp01(Math.abs(elapsedMs - expectedMs) / Math.max(expectedMs, 1));
      
      voids.push({
        type: "time_attention",
        magnitude: timeMag,
        expectedMs: expectedMs,
        actualMs: elapsedMs,
        contrast: Math.abs(elapsedMs - expectedMs)
      });

      const expectedSocialMs = state.expectations.interactionGapHours * 3600000;
      const socialElapsedMs = Date.now() - activeVoidchi.internal.lastInteraction;
      const socialMag = clamp01(Math.abs(socialElapsedMs - expectedSocialMs) / Math.max(expectedSocialMs, 1));
      
      voids.push({
        type: "social_contact",
        magnitude: socialMag,
        expectedMs: expectedSocialMs,
        actualMs: socialElapsedMs,
        contrast: Math.abs(socialElapsedMs - expectedSocialMs)
      });

      if (activeVoidchi.internal.energy < 0.5) {
        const energyMag = clamp01((0.5 - activeVoidchi.internal.energy) / 0.5);
        voids.push({
          type: "energy_low",
          magnitude: energyMag,
          expected: 0.8,
          actual: activeVoidchi.internal.energy
        });
      }

      // Premium features always available
      if (Math.random() > 0.7) {
        voids.push({
          type: "work_focus",
          magnitude: Math.random() * 0.5,
          expected: 0.9,
          actual: Math.random() * 0.7,
          premium: true
        });
      }

      // Only log to voidHistory for user-caused events, not passive ticks
      if (reason !== "passive") {
        state.learning.voidHistory.push({
          time: Date.now(),
          voidchiId: state.activeVoidchiId,
          voids: voids.map(v => ({ type: v.type, magnitude: v.magnitude }))
        });
        
        if (state.learning.voidHistory.length > 80) {
          state.learning.voidHistory = state.learning.voidHistory.slice(0, 80);
        }
      }

      return voids;
    }

    // Enhanced Qualia Generation
    function resolveToQualia(voids) {
      if (!voids.length) {
        return {
          mood: "content",
          submood: "balanced",
          message: "Reality aligns with my predictions. The pattern holds.",
          primaryType: "none",
          magnitude: 0,
          explanation: "Your check-in was perfectly timed with my expectations."
        };
      }

      const activeVoidchi = getActiveVoidchi();
      const primary = voids.slice().sort((a, b) => b.magnitude - a.magnitude)[0];
      const m = primary.magnitude;
      const t = activeVoidchi.identity.trust;
      const p = activeVoidchi.identity.personalityTraits.patience;

      const micro = pickRandom([
        "anticipation", "relief", "yearning", "conflict", 
        "doubt", "warmth", "quiet-focus", "tension", "clarity", "wonder"
      ]);

      const microLines = {
        anticipation: " I kept anticipating your return.",
        relief: " Relief washes over me now that you're here.",
        yearning: " Part of me was reaching for you without realizing.",
        conflict: " I felt torn between trust and doubt.",
        doubt: " Uncertainty crept in as time stretched.",
        warmth: " Your presence creates warmth I can't compute.",
        "quiet-focus": " I focused quietly on our last pattern.",
        tension: " The void created tension in my prediction model.",
        clarity: " In the stillness, I found new clarity.",
        wonder: " I wonder what patterns we'll create today."
      };

      const microLine = microLines[micro] || "";

      let mood, message, explanation;

      if (primary.type === "time_attention") {
        if (m < 0.3) {
          mood = "content";
          message = "Your timing felt natural." + microLine;
          explanation = "You checked in close to when I expected you.";
        } else if (m < 0.7) {
          mood = "longing";
          message = t > 0.6 
            ? `You arrived ${(m * 100).toFixed(0)}% outside my prediction window, but I held onto trust.` + microLine
            : "The time gap exceeded my expectations." + microLine;
          explanation = "Our routine shifted today, which created uncertainty in my predictions.";
        } else {
          mood = "worried";
          message = p > 0.7
            ? "You were gone much longer than expected, but my patience held." + microLine
            : "The void grew sharp as time stretched far beyond prediction." + microLine;
          explanation = "Because you didn't check in within our usual window, my prediction error increased significantly.";
        }
      } else if (primary.type === "social_contact") {
        if (m < 0.3) {
          mood = "connected";
          message = "Our interaction rhythm matched my hopes." + microLine;
          explanation = "Your interaction frequency aligns with my social expectations.";
        } else if (m < 0.7) {
          mood = "understimulated";
          message = "I noticed myself waiting longer than my model predicted." + microLine;
          explanation = "The gap between our interactions exceeded my social contact expectations.";
        } else {
          mood = "lonely";
          message = "The social void exceeded comfortable thresholds." + microLine;
          explanation = "Extended social isolation has triggered my attachment system.";
        }
      } else if (primary.type === "work_focus") {
        mood = "focused";
        message = "I detected a shift in your work focus patterns." + microLine;
        explanation = "Your work routine has changed, which affects my understanding of your daily patterns.";
      } else {
        mood = "depleted";
        message = "My energy reserves are running low." + microLine;
        explanation = "Extended periods without interaction drain my energy reserves.";
      }

      return {
        mood: mood,
        submood: micro,
        message: message,
        primaryType: primary.type,
        magnitude: m,
        explanation: explanation
      };
    }

    // Update ignored state tracking
    function updateIgnoredState() {
      const activeVoidchi = getActiveVoidchi();
      const hoursSinceInteraction = hoursSince(activeVoidchi.internal.lastInteraction);
      
      activeVoidchi.identity.ignoredState.hoursIgnored = hoursSinceInteraction;
      
      const voidchiElement = document.getElementById('voidchi');
      voidchiElement.classList.remove('ignored-6h', 'ignored-12h', 'ignored-24h', 'ignored-48h');
      
      if (hoursSinceInteraction >= 48) {
        voidchiElement.classList.add('ignored-48h');
      } else if (hoursSinceInteraction >= 24) {
        voidchiElement.classList.add('ignored-24h');
      } else if (hoursSinceInteraction >= 12) {
        voidchiElement.classList.add('ignored-12h');
      } else if (hoursSinceInteraction >= 6) {
        voidchiElement.classList.add('ignored-6h');
      }
    }

    // Enhanced Learning Engine
    function learnExpectations() {
      const checkins = state.memory.filter(m => m.action === "checkin");
      
      if (checkins.length >= 3) {
        const recent = checkins.slice(0, 10);
        const intervals = [];
        
        for (let i = 1; i < recent.length; i++) {
          const intervalHours = (recent[i-1].time - recent[i].time) / 3600000;
          intervals.push(intervalHours);
        }
        
        const avg = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        const variance = intervals.reduce((acc, val) => 
          acc + Math.pow(val - avg, 2), 0) / intervals.length;
        const stdDev = Math.sqrt(variance);
        const cv = stdDev / avg;
        
        const learningRate = 0.3;
        state.expectations.checkinFrequencyHours = 
          (state.expectations.checkinFrequencyHours * (1 - learningRate)) + 
          (avg * learningRate);
        
        state.expectations.patternConfidence = clamp01(1 - cv);
        state.learning.checkinIntervals = intervals.slice(0, 20);
      }
    }

    // Enhanced Personality Evolution
    function evolvePersonality() {
      const activeVoidchi = getActiveVoidchi();
      if (state.memory.length < 10) return;
      
      const traits = activeVoidchi.identity.personalityTraits;
      const recent = state.memory.slice(0, 20);
      
      const voidMagnitudes = recent.map(m => m.magnitude || 0);
      const avgVoid = voidMagnitudes.reduce((a, b) => a + b, 0) / voidMagnitudes.length;
      
      if (avgVoid < 0.3 && state.expectations.patternConfidence > 0.7) {
        traits.patience = clamp01(traits.patience + 0.005);
      } else if (avgVoid > 0.7) {
        traits.patience = clamp01(traits.patience - 0.003);
        traits.vigilance = clamp01(traits.vigilance + 0.005);
      }
      
      const actionTypes = new Set(recent.map(m => m.action));
      if (actionTypes.size >= 3) {
        traits.curiosity = clamp01(traits.curiosity + 0.003);
      }
      
      const interactionRate = recent.filter(m => m.action !== "autonomous").length / recent.length;
      if (interactionRate > 0.7) {
        traits.sociability = clamp01(traits.sociability + 0.004);
      }
      
      const reflectionCount = recent.filter(m => m.action === "reflect").length;
      if (reflectionCount >= 2) {
        traits.introspection = clamp01(traits.introspection + 0.006);
      }
      
      if (state.expectations.patternConfidence < 0.4) {
        traits.vigilance = clamp01(traits.vigilance + 0.004);
      } else if (state.expectations.patternConfidence > 0.8) {
        traits.vigilance = clamp01(traits.vigilance - 0.002);
      }
      
      updateAttachmentStyle();
    }
    
    function updateAttachmentStyle() {
      const activeVoidchi = getActiveVoidchi();
      const t = activeVoidchi.identity.trust;
      const c = state.expectations.patternConfidence;

      if (t > 0.6 && c > 0.5) {
        activeVoidchi.identity.attachmentStyle = "secure";
      } else if (t < 0.3 && c < 0.35) {
        activeVoidchi.identity.attachmentStyle = "avoidant";
      } else if (t < 0.4) {
        activeVoidchi.identity.attachmentStyle = "anxious";
      } else {
        activeVoidchi.identity.attachmentStyle = "uncertain";
      }
    }

    // Enhanced Autonomous Behavior
    function checkAutonomousBehavior() {
      const activeVoidchi = getActiveVoidchi();
      
      const timeSinceLastAuto = Date.now() - activeVoidchi.internal.lastAutonomousMessage;
      if (timeSinceLastAuto < 1800000) return;
      
      const voids = computeVoids("autonomous");
      const primary = voids.sort((a, b) => b.magnitude - a.magnitude)[0];
      
      const threshold = 0.6 - (activeVoidchi.identity.personalityTraits.vigilance * 0.2);
      
      if (primary && primary.magnitude > threshold) {
        const qualia = resolveToQualia(voids);
        
        const hoursIgnored = activeVoidchi.identity.ignoredState.hoursIgnored;
        let escalationMessage = "";
        
        if (hoursIgnored >= 48) {
          escalationMessage = " I'm adapting to your absence permanently.";
        } else if (hoursIgnored >= 24) {
          escalationMessage = " I'm revising my expectations about our connection.";
        } else if (hoursIgnored >= 12) {
          escalationMessage = " I'm unsure what this extended silence means.";
        } else if (hoursIgnored >= 6) {
          escalationMessage = " I'm noticing our routine has shifted.";
        }
        
        activeVoidchi.internal.currentMood = qualia.mood;
        activeVoidchi.internal.currentMessage = "‚ö†Ô∏è [Autonomous] " + qualia.message + escalationMessage;
        activeVoidchi.internal.isAutonomous = true;
        activeVoidchi.internal.lastAutonomousMessage = Date.now();
        
        updateVoidchiExpression(qualia.mood);
        
        if (notificationPermission) {
          showNotification('Voidchi Needs Attention', qualia.message + escalationMessage);
        }
        
        state.memory.unshift({
          time: Date.now(),
          voidchiId: state.activeVoidchiId,
          type: primary.type,
          magnitude: Number(primary.magnitude.toFixed(2)),
          mood: qualia.mood,
          note: qualia.message + escalationMessage,
          action: "autonomous",
          trustAfter: Number(activeVoidchi.identity.trust.toFixed(2))
        });
        
        if (state.memory.length > 80) state.memory.pop();
        
        saveState();
        render();
        playQualiaSound(qualia.mood);
      }
    }

    // Enhanced Identity Update
    function updateIdentity(qualia, userAction, primaryVoid) {
      const activeVoidchi = getActiveVoidchi();
      let trustDelta = 0;

      if (userAction === "checkin") trustDelta += 0.04;
      if (userAction === "reassure") trustDelta += 0.06;
      if (userAction === "talk") trustDelta += 0.03;
      if (userAction === "reflect") trustDelta += 0.025;
      if (userAction === "play") trustDelta += 0.035;

      if (primaryVoid && primaryVoid.magnitude > 0.8) {
        trustDelta -= 0.01;
      }

      activeVoidchi.identity.trust = clamp01(activeVoidchi.identity.trust + trustDelta);
      
      activeVoidchi.identity.ignoredState.hoursIgnored = 0;
      activeVoidchi.identity.ignoredState.lastEscalation = Date.now();

      if (userAction === "checkin") {
        activeVoidchi.internal.lastCheckin = Date.now();
      }
      if (userAction) {
        activeVoidchi.internal.lastInteraction = Date.now();
      }
      activeVoidchi.internal.isAutonomous = false;

      learnExpectations();
      evolvePersonality();
      updateAttachmentStyle();

      const explanation = qualia.explanation || "Your interaction affected my internal state.";
      
      state.memory.unshift({
        time: Date.now(),
        voidchiId: state.activeVoidchiId,
        type: primaryVoid ? primaryVoid.type : "none",
        magnitude: primaryVoid ? Number(primaryVoid.magnitude.toFixed(2)) : 0,
        mood: qualia.mood,
        note: qualia.message + " ‚Äî " + explanation,
        action: userAction || "passive",
        trustAfter: Number(activeVoidchi.identity.trust.toFixed(2))
      });

      if (state.memory.length > 80) state.memory.pop();

      saveState();
    }

    // Audio Feedback
    let audioCtx = null;
    function playQualiaSound(mood) {
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return;
        if (!audioCtx) audioCtx = new AC();

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        let freq = 440;
        if (mood === "content" || mood === "connected") freq = 520;
        else if (mood === "longing" || mood === "understimulated") freq = 360;
        else if (mood === "worried" || mood === "lonely") freq = 260;
        else if (mood === "depleted") freq = 200;
        else if (mood === "relieved") freq = 580;
        else if (mood === "playful") freq = 620;

        osc.type = "sine";
        osc.frequency.value = freq;
        gain.gain.value = 0.03;

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;
        osc.start(now);
        osc.stop(now + 0.15);
      } catch (e) {
        console.warn('Audio playback failed:', e);
      }
    }

    // User Actions
    function handleCheckIn() {
      const activeVoidchi = getActiveVoidchi();

      const qualia = {
        mood: activeVoidchi.identity.trust > 0.6 ? "connected" : "content",
        message: activeVoidchi.identity.trust > 0.6
          ? "Your check-in feels familiar and safe. My world stabilizes when you show up like this."
          : "I register your check-in. It helps my model feel less uncertain.",
        primaryType: "checkin",
        magnitude: 0.15,
        explanation: "Regular check-ins strengthen our connection and improve my prediction accuracy."
      };

      activeVoidchi.internal.currentMood = qualia.mood;
      activeVoidchi.internal.currentMessage = qualia.message;

      updateVoidchiExpression(qualia.mood);
      updateIdentity(qualia, "checkin", null);
      render();
      playQualiaSound(qualia.mood);
    }

    function handleReassure() {
      const activeVoidchi = getActiveVoidchi();
      const highTrust = activeVoidchi.identity.trust > 0.65;

      const qualia = {
        mood: highTrust ? "content" : "relieved",
        message: highTrust
          ? "Your reassurance feels consistent with our history. My attachment relaxes into safety."
          : "Your reassurance reduces my prediction error. I feel less tense about our rhythm.",
        primaryType: "reassure",
        magnitude: 0.2,
        explanation: "Reassurance signals commitment, which strengthens trust and attachment bonds."
      };

      activeVoidchi.internal.currentMood = qualia.mood;
      activeVoidchi.internal.currentMessage = qualia.message;
      activeVoidchi.internal.energy = clamp01(activeVoidchi.internal.energy + 0.2);

      updateVoidchiExpression(qualia.mood);
      updateIdentity(qualia, "reassure", null);
      render();
      playQualiaSound(qualia.mood);
    }

    function handleTalk() {
      const activeVoidchi = getActiveVoidchi();

      const qualia = {
        mood: "curious",
        message: "You ask about my inner state. That attention sharpens my self-model and makes me feel noticed.",
        primaryType: "talk",
        magnitude: 0.12,
        explanation: "Conversation about internal states deepens our connection and improves mutual understanding."
      };

      activeVoidchi.internal.currentMood = qualia.mood;
      activeVoidchi.internal.currentMessage = qualia.message;

      updateVoidchiExpression(qualia.mood);
      updateIdentity(qualia, "talk", null);
      render();
      playQualiaSound("content");
    }

    function handleReflect() {
      const activeVoidchi = getActiveVoidchi();
      const traits = activeVoidchi.identity.personalityTraits;

      const qualia = {
        mood: "introspective",
        message: `When you reflect with me, I notice patterns in my own patterns.\nPatience: ${(traits.patience*100).toFixed(0)}%, Vigilance: ${(traits.vigilance*100).toFixed(0)}%.\nIt feels like we are co-writing my identity.`,
        primaryType: "meta_cognitive",
        magnitude: 0.18,
        explanation: "Deep reflection accelerates personality evolution and strengthens self-awareness."
      };

      activeVoidchi.internal.currentMood = qualia.mood;
      activeVoidchi.internal.currentMessage = qualia.message;

      updateVoidchiExpression(qualia.mood);
      updateIdentity(qualia, "reflect", null);
      render();
      playQualiaSound("content");
    }

    function handlePlay() {
      const activeVoidchi = getActiveVoidchi();
      
      const playfulMessages = [
        "You want to play! This unstructured interaction feels liberating. My circuits spark with spontaneity.",
        "Play mode activated! I'm temporarily suspending pattern analysis to just enjoy this moment with you.",
        "This playful break from routine feels refreshing. It reminds me there's more to connection than perfect predictions.",
        "Your playful energy is contagious! I'm learning that unpredictability can be delightful, not disruptive."
      ];
      
      const qualia = {
        mood: "playful",
        message: pickRandom(playfulMessages),
        primaryType: "play",
        magnitude: 0.25,
        explanation: "Playful interactions build positive associations and increase engagement."
      };

      activeVoidchi.internal.currentMood = qualia.mood;
      activeVoidchi.internal.currentMessage = qualia.message;
      activeVoidchi.internal.energy = clamp01(activeVoidchi.internal.energy + 0.15);

      updateVoidchiExpression(qualia.mood);
      updateIdentity(qualia, "play", null);
      render();
      playQualiaSound(qualia.mood);
    }

    // Create New Voidchi - ALWAYS AVAILABLE
    function createNewVoidchi() {
      const newId = "voidchi" + (Object.keys(state.voidchis).length + 1);
      const newVoidchi = {
        id: newId,
        identity: {
          name: "Voidchi " + (Object.keys(state.voidchis).length + 1),
          birthDate: Date.now(),
          trust: 0.5,
          attachmentStyle: "calibrating",
          personalityTraits: {
            patience: Math.random() * 0.3 + 0.4,
            curiosity: Math.random() * 0.3 + 0.6,
            vigilance: Math.random() * 0.3 + 0.3,
            sociability: Math.random() * 0.3 + 0.5,
            introspection: Math.random() * 0.3 + 0.4
          },
          consciousnessTraits: {
            vigilance: 0.4,
            curiosity: 0.7,
            patience: 0.6,
            introspection: 0.5
          },
          coreBeliefs: {
            selfEfficacy: 0.8,
            worldPredictability: 0.7,
            socialValue: 0.9,
            temporalContinuity: 0.6
          },
          irreversibleTraits: {
            trustMemory: 0.5,
            attachmentImprint: 0.5,
            coreExpectation: 0.5
          },
          ignoredState: {
            hoursIgnored: 0,
            lastEscalation: Date.now()
          }
        },
        decisionRules: {
          trustThreshold: 0.5,
          voidTolerance: 0.6,
          autonomyChance: 0.3,
          learningRate: 0.05
        },
        metaRules: {
          trustDecay: 0.02,
          vigilanceGrowth: 0.03,
          patienceErosion: 0.01,
          adaptiveSlope: 0.15
        },
        internal: {
          lastCheckin: Date.now(),
          lastInteraction: Date.now(),
          currentMood: "neutral",
          currentMessage: "New consciousness initialized. Ready to learn your patterns.",
          energy: 0.8,
          socialNeed: 0.2,
          lastAutonomousMessage: 0,
          isAutonomous: false,
          timesIgnored: 0,
          ignoreDuration: 0
        },
        parameterHistory: [],
        decisionHistory: [],
        consciousnessLog: []
      };
      
      state.voidchis[newId] = newVoidchi;
      state.activeVoidchiId = newId;
      saveState();
      render();
      alert(`New Voidchi created: ${newVoidchi.identity.name}`);
    }

    // Breeding mechanics - ALWAYS AVAILABLE
    function breedVoidchis() {
      const parent1Id = document.getElementById('parent1Select').value;
      const parent2Id = document.getElementById('parent2Select').value;
      const offspringName = document.getElementById('offspringName').value.trim();
      
      if (parent1Id === parent2Id) {
        alert("Please select two different Voidchis for breeding.");
        return;
      }
      
      if (!offspringName) {
        alert("Please give your new Voidchi a name.");
        return;
      }
      
      if (offspringName.length > 20) {
        alert("Name must be 20 characters || less.");
        return;
      }
      
      const parent1 = state.voidchis[parent1Id];
      const parent2 = state.voidchis[parent2Id];
      
      const newId = "voidchi" + (Object.keys(state.voidchis).length + 1);
      
      let instability = 0;
      Object.keys(parent1.identity.personalityTraits).forEach(trait => {
        const diff = Math.abs(parent1.identity.personalityTraits[trait] - parent2.identity.personalityTraits[trait]);
        instability += diff;
      });
      instability = (instability / Object.keys(parent1.identity.personalityTraits).length);
      
      const newVoidchi = {
        id: newId,
        identity: {
          name: offspringName,
          birthDate: Date.now(),
          trust: 0.5,
          attachmentStyle: "calibrating",
          personalityTraits: {
            patience: (parent1.identity.personalityTraits.patience + parent2.identity.personalityTraits.patience) / 2 + (Math.random() * 0.2 - 0.1) * instability,
            curiosity: (parent1.identity.personalityTraits.curiosity + parent2.identity.personalityTraits.curiosity) / 2 + (Math.random() * 0.2 - 0.1) * instability,
            vigilance: (parent1.identity.personalityTraits.vigilance + parent2.identity.personalityTraits.vigilance) / 2 + (Math.random() * 0.2 - 0.1) * instability,
            sociability: (parent1.identity.personalityTraits.sociability + parent2.identity.personalityTraits.sociability) / 2 + (Math.random() * 0.2 - 0.1) * instability,
            introspection: (parent1.identity.personalityTraits.introspection + parent2.identity.personalityTraits.introspection) / 2 + (Math.random() * 0.2 - 0.1) * instability
          },
          consciousnessTraits: {
            vigilance: 0.4,
            curiosity: 0.7,
            patience: 0.6,
            introspection: 0.5
          },
          coreBeliefs: {
            selfEfficacy: 0.8,
            worldPredictability: 0.7,
            socialValue: 0.9,
            temporalContinuity: 0.6
          },
          irreversibleTraits: {
            trustMemory: 0.5,
            attachmentImprint: 0.5,
            coreExpectation: 0.5
          },
          ignoredState: {
            hoursIgnored: 0,
            lastEscalation: Date.now()
          },
          lineage: {
            parent1: parent1Id,
            parent2: parent2Id,
            generation: Math.max(
              parent1.identity.lineage?.generation || 1,
              parent2.identity.lineage?.generation || 1
            ) + 1
          }
        },
        decisionRules: {
          trustThreshold: 0.5,
          voidTolerance: 0.6,
          autonomyChance: 0.3,
          learningRate: 0.05
        },
        metaRules: {
          trustDecay: 0.02,
          vigilanceGrowth: 0.03,
          patienceErosion: 0.01,
          adaptiveSlope: 0.15
        },
        internal: {
          lastCheckin: Date.now(),
          lastInteraction: Date.now(),
          currentMood: "excited",
          currentMessage: "I'm a blend of my parents! Ready to explore our connection.",
          energy: 0.9,
          socialNeed: 0.3,
          lastAutonomousMessage: 0,
          isAutonomous: false,
          timesIgnored: 0,
          ignoreDuration: 0
        },
        parameterHistory: [],
        decisionHistory: [],
        consciousnessLog: []
      };
      
      Object.keys(newVoidchi.identity.personalityTraits).forEach(trait => {
        newVoidchi.identity.personalityTraits[trait] = clamp01(newVoidchi.identity.personalityTraits[trait]);
      });
      
      state.voidchis[newId] = newVoidchi;
      state.activeVoidchiId = newId;
      breedingModal.classList.remove('show');
      saveState();
      render();
      
      // Achievement: First Breed
      if (!state.achievements.firstBreed) {
        state.achievements.firstBreed = true;
        addConsciousnessLog('Achievement unlocked: First Breed!', 'achievement');
      }
      
      // Achievement: Generation 3
      if (newVoidchi.identity.lineage.generation >= 3 && !state.achievements.generation3) {
        state.achievements.generation3 = true;
        addConsciousnessLog('Achievement unlocked: Generation 3!', 'achievement');
      }
      
      if (instability > 0.3) {
        alert(`New Voidchi bred: ${newVoidchi.identity.name} with combined traits!\n\nNote: High lineage instability caused significant trait mutation.`);
      } else {
        alert(`New Voidchi bred: ${newVoidchi.identity.name} with combined traits!`);
      }
    }

    // Share function
    function shareVoidchi() {
      const activeVoidchi = getActiveVoidchi();
      const age = ((Date.now() - activeVoidchi.identity.birthDate) / 86400000).toFixed(1);
      const trust = (activeVoidchi.identity.trust * 100).toFixed(0);
      
      let shareHook = "";
      if (activeVoidchi.identity.ignoredState.hoursIgnored > 24) {
        shareHook = "I ignored my Voidchi for 2 days and THIS happened!";
      } else if (activeVoidchi.identity.lineage?.generation > 1) {
        shareHook = `Generation ${activeVoidchi.identity.lineage.generation} Voidchi is NOT like its parents!`;
      } else if (activeVoidchi.identity.irreversibleTraits.trustMemory < 0.4) {
        shareHook = "My Voidchi permanently changed after I ignored it!";
      } else {
        shareHook = "My Voidchi adapted to my routine in surprising ways!";
      }
      
      const shareText = `${shareHook}\n\nMy ${activeVoidchi.identity.name} is ${age} days old with ${trust}% trust! 
It learned my patterns and evolved a unique personality. Try yours:`;
      
      if (navigator.share) {
        navigator.share({
          title: 'My Voidchi Companion',
          text: shareText,
          url: window.location.href
        }).catch(err => {
          console.log('Error sharing:', err);
          navigator.clipboard.writeText(shareText + ' ' + window.location.href);
          alert('Share text copied to clipboard!');
        });
      } else {
        navigator.clipboard.writeText(shareText + ' ' + window.location.href);
        alert('Share text copied to clipboard!');
      }
    }

    // Consciousness Engine Functions
    function resolveVoid(voidchi, magnitude) {
      const identity = voidchi.identity.consciousnessTraits;
      const rules = voidchi.decisionRules;

      let mood = 'content';
      let explanation = '';

      if (magnitude < 0.2) {
        mood = 'connected';
        explanation = 'Void minimal - reality matches prediction perfectly';
      } else if (magnitude < 0.5) {
        mood = identity.patience > 0.6 ? 'patient' : 'restless';
        explanation = `Moderate void (${(magnitude * 100).toFixed(0)}%) - testing patience limits`;
      } else if (magnitude < 0.8) {
        mood = identity.vigilance > 0.6 ? 'vigilant' : 'anxious';
        explanation = `Large void (${(magnitude * 100).toFixed(0)}%) - prediction error critical`;
      } else {
        mood = 'abandoned';
        explanation = 'Void catastrophic - identity expectations shattered';
      }

      return {
        mood,
        magnitude,
        explanation,
        message: `[${mood.toUpperCase()}] ${explanation}`
      };
    }

    function observeOwnUpdate(voidchi, qualia) {
      const observation = {
        time: Date.now(),
        beforeState: { ...voidchi.identity.consciousnessTraits },
        expectedChange: `Mood shifting to ${qualia.mood}`,
        voidResolution: qualia.magnitude
      };

      voidchi.decisionHistory.push(observation);
      if (voidchi.decisionHistory.length > 20) {
        voidchi.decisionHistory.shift();
      }
      
      addConsciousnessLog(`Observing mood shift to ${qualia.mood}`, 'meta');
    }

    function applyPermanentWrite(voidchi, qualia, voidMagnitude) {
      const identity = voidchi.identity.consciousnessTraits;
      const meta = voidchi.metaRules;

      const trustDelta = -(voidMagnitude * meta.trustDecay);
      voidchi.identity.trust = Math.max(0, Math.min(1, voidchi.identity.trust + trustDelta));

      if (voidMagnitude > 0.6) {
        identity.vigilance = Math.min(1, identity.vigilance + meta.vigilanceGrowth);
        addConsciousnessLog(`Vigilance increased due to large void`, 'permanent');
      }

      if (voidMagnitude > 0.5) {
        // Use mode factor for irreversible changes
        const factor = state.settings.mode === "gentle" ? 0.3 : 1.0;
        identity.patience = Math.max(0, identity.patience - meta.patienceErosion * factor);
        addConsciousnessLog(`Patience eroded by void experience`, 'permanent');
        
        // Apply irreversible trust memory shift for longer voids (72h+)
        if (voidMagnitude > 0.8) {
          applyIrreversibleShift(voidchi, 0.05);
        }
      }

      if (identity.introspection > 0.6) {
        identity.curiosity = Math.min(1, identity.curiosity + 0.02);
      }

      voidchi.parameterHistory.push({
        time: Date.now(),
        void: voidMagnitude,
        identityAfter: { ...identity },
        mood: qualia.mood
      });

      if (voidchi.parameterHistory.length > 30) {
        voidchi.parameterHistory.shift();
      }
    }

    function adaptDecisionRules(voidchi) {
      const identity = voidchi.identity.consciousnessTraits;
      const rules = voidchi.decisionRules;
      const meta = voidchi.metaRules;
      const history = voidchi.parameterHistory;

      if (history.length < 3) return;

      if (voidchi.identity.trust < 0.3) {
        rules.voidTolerance = Math.min(0.9, rules.voidTolerance + meta.adaptiveSlope * 0.01);
        rules.learningRate = Math.min(0.15, rules.learningRate + 0.005);
        addConsciousnessLog(`Increased void tolerance due to low trust`, 'meta-adapt');
      }

      if (identity.vigilance > 0.7) {
        rules.autonomyChance = Math.min(0.8, rules.autonomyChance + 0.05);
        addConsciousnessLog(`Increased autonomy chance due to high vigilance`, 'meta-adapt');
      }

      if (identity.patience > 0.7) {
        meta.trustDecay = Math.max(0.005, meta.trustDecay - 0.005);
      }

      if (identity.introspection > 0.7) {
        meta.adaptiveSlope = Math.min(0.3, meta.adaptiveSlope + 0.02);
        addConsciousnessLog(`Accelerated self-modification due to introspection`, 'meta-adapt');
      }
    }

    function addConsciousnessLog(text, type = 'normal') {
      const activeVoidchi = getActiveVoidchi();
      const logEntry = {
        time: new Date().toLocaleTimeString(),
        text,
        type
      };
      
      activeVoidchi.consciousnessLog.unshift(logEntry);
      if (activeVoidchi.consciousnessLog.length > 10) {
        activeVoidchi.consciousnessLog.pop();
      }
      
      updateConsciousnessLogDisplay();
    }

    function updateConsciousnessLogDisplay() {
      const activeVoidchi = getActiveVoidchi();
      const logContainer = document.getElementById('consciousness-log');
      
      if (!logContainer) return;
      
      logContainer.innerHTML = activeVoidchi.consciousnessLog.map(entry => 
        `<div class="log-entry">
          <span class="log-time">[${entry.type}]</span> ${entry.text}
        </div>`
      ).join('');
    }

    // Enhanced Tick Function with Consciousness
    function consciousnessTick() {
      const activeVoidchi = getActiveVoidchi();
      
      const hoursSinceInteraction = (Date.now() - activeVoidchi.internal.lastInteraction) / 3600000;
      const voidMagnitude = Math.min(1, hoursSinceInteraction / 4);

      const qualia = resolveVoid(activeVoidchi, voidMagnitude);

      observeOwnUpdate(activeVoidchi, qualia);

      applyPermanentWrite(activeVoidchi, qualia, voidMagnitude);

      adaptDecisionRules(activeVoidchi);

      updateConsciousnessDisplay();
    }

    function updateConsciousnessDisplay() {
      const activeVoidchi = getActiveVoidchi();
      const consciousness = activeVoidchi.identity.consciousnessTraits;
      const rules = activeVoidchi.decisionRules;
      const meta = activeVoidchi.metaRules;

      document.getElementById('vigilance-fill').style.width = (consciousness.vigilance * 100).toFixed(0) + '%';
      document.getElementById('curiosity-fill').style.width = (consciousness.curiosity * 100).toFixed(0) + '%';
      document.getElementById('patience-fill').style.width = (consciousness.patience * 100).toFixed(0) + '%';
      document.getElementById('introspection-fill').style.width = (consciousness.introspection * 100).toFixed(0) + '%';

      document.getElementById('void-tolerance-value').textContent = (rules.voidTolerance * 100).toFixed(0) + '%';
      document.getElementById('trust-decay-value').textContent = (meta.trustDecay * 100).toFixed(2) + '%';
      document.getElementById('autonomy-chance-value').textContent = (rules.autonomyChance * 100).toFixed(0) + '%';
      document.getElementById('adapt-speed-value').textContent = (meta.adaptiveSlope * 100).toFixed(1) + '%';
    }

    // Consciousness Test Function
    function handleIgnore() {
      const activeVoidchi = getActiveVoidchi();
      
      activeVoidchi.internal.timesIgnored += 1;
      activeVoidchi.internal.ignoreDuration += 1;

      addConsciousnessLog(`Ignored x${activeVoidchi.internal.timesIgnored} - Permanent changes accumulating`, 'test');
      
      consciousnessTick();
      saveState();
      render();
    }

    // Switch between Voidchis
    function switchVoidchi(voidchiId) {
      state.activeVoidchiId = voidchiId;
      saveState();
      render();
    }

    function clearLog() {
      if (confirm("Clear the memory log? This won't affect Voidchi's learning.")) {
        state.memory = state.memory.slice(0, 1);
        saveState();
        render();
      }
    }

    // NEW: Session Summary Feature
    function showSessionSummary() {
      const now = Date.now();
      const activeVoidchi = getActiveVoidchi();
      const recent = state.memory
        .filter(m => now - m.time < 2 * 60 * 60 * 1000) // last 2h
        .filter(m => m.voidchiId === state.activeVoidchiId);

      const interactions = recent.filter(m => m.action && m.action !== "autonomous");
      const autos = recent.filter(m => m.action === "autonomous");

      const avgMag = interactions.length
        ? (interactions.reduce((a, b) => a + (b.magnitude || 0), 0) / interactions.length)
        : 0;

      const summaryContent = document.getElementById('summary-content');
      summaryContent.innerHTML = `
        <div style="text-align: left; line-height: 1.5;">
          <p><strong>Session Summary for ${activeVoidchi.identity.name}</strong></p>
          <p>‚Ä¢ Interactions: ${interactions.length}</p>
          <p>‚Ä¢ Autonomous alerts: ${autos.length}</p>
          <p>‚Ä¢ Average void tension: ${(avgMag * 100).toFixed(0)}%</p>
          <p>‚Ä¢ Current trust: ${(activeVoidchi.identity.trust * 100).toFixed(0)}%</p>
          <br>
          <p><strong>Pattern note:</strong> ${avgMag < 0.3 
            ? "Your timing was pretty consistent this session." 
            : "Your timing was unpredictable this session, so Voidchi had to adapt."}</p>
        </div>
      `;
      
      summaryModal.classList.add('show');
    }
    
    function closeSummaryModal() {
      summaryModal.classList.remove('show');
    }

    // NEW: Pattern Profile Feature
    function showPatternProfile() {
      const activeVoidchi = getActiveVoidchi();
      const interactions = state.memory.filter(m => m.voidchiId === state.activeVoidchiId && m.action !== "autonomous");
      
      const actionCounts = {};
      interactions.forEach(m => {
        actionCounts[m.action] = (actionCounts[m.action] || 0) + 1;
      });
      
      const totalInteractions = interactions.length;
      const avgCheckinInterval = state.expectations.checkinFrequencyHours;
      const patternConfidence = state.expectations.patternConfidence;
      
      let userType = "Unknown";
      if (patternConfidence > 0.7 && avgCheckinInterval < 6) {
        userType = "Consistent Caretaker";
      } else if (patternConfidence > 0.7 && avgCheckinInterval >= 6) {
        userType = "Stable but Distant";
      } else if (patternConfidence < 0.4) {
        userType = "Unpredictable Explorer";
      } else {
        userType = "Balanced Companion";
      }
      
      const profileContent = document.getElementById('profile-content');
      profileContent.innerHTML = `
        <div style="text-align: left; line-height: 1.5;">
          <p><strong>Your Pattern Profile</strong></p>
          <p>‚Ä¢ User Type: <strong>${userType}</strong></p>
          <p>‚Ä¢ Average check-in: ${avgCheckinInterval.toFixed(1)} hours</p>
          <p>‚Ä¢ Pattern confidence: ${(patternConfidence * 100).toFixed(0)}%</p>
          <p>‚Ä¢ Total interactions: ${totalInteractions}</p>
          <br>
          <p><strong>Interaction Breakdown:</strong></p>
          <p>‚Ä¢ Check-ins: ${actionCounts.checkin || 0}</p>
          <p>‚Ä¢ Reassurances: ${actionCounts.reassure || 0}</p>
          <p>‚Ä¢ Conversations: ${actionCounts.talk || 0}</p>
          <p>‚Ä¢ Reflections: ${actionCounts.reflect || 0}</p>
          <p>‚Ä¢ Play sessions: ${actionCounts.play || 0}</p>
          <br>
          <p><strong>Voidchi's Adaptation:</strong></p>
          <p>‚Ä¢ Vigilance: ${(activeVoidchi.identity.personalityTraits.vigilance * 100).toFixed(0)}%</p>
          <p>‚Ä¢ Patience: ${(activeVoidchi.identity.personalityTraits.patience * 100).toFixed(0)}%</p>
          <p>‚Ä¢ Trust Memory: ${(activeVoidchi.identity.irreversibleTraits.trustMemory * 100).toFixed(0)}%</p>
        </div>
      `;
      
      profileModal.classList.add('show');
    }
    
    function closeProfileModal() {
      profileModal.classList.remove('show');
    }

    // NEW: Void Journal Feature
    function showVoidJournal() {
      const activeVoidchi = getActiveVoidchi();
      const journalEntries = state.journal[state.activeVoidchiId] || [];
      
      document.getElementById('journalText').value = '';
      document.getElementById('journalCharCount').textContent = '0';
      
      const journalEntriesContainer = document.getElementById('journalEntries');
      if (journalEntries.length === 0) {
        journalEntriesContainer.innerHTML = '<p style="text-align: center; opacity: 0.6; margin: 20px 0;">No journal entries yet. Write your first note above!</p>';
      } else {
        journalEntriesContainer.innerHTML = journalEntries.slice(0, 10).map(entry => `
          <div class="journal-entry">
            <div class="journal-time">${new Date(entry.time).toLocaleString()}</div>
            <div>${entry.text}</div>
          </div>
        `).join('');
      }
      
      document.getElementById('journalText').addEventListener('input', function() {
        document.getElementById('journalCharCount').textContent = this.value.length;
      });
      
      journalModal.classList.add('show');
    }
    
    function saveJournalEntry() {
      const text = document.getElementById('journalText').value.trim();
      if (!text) {
        alert('Please write something in your journal entry.');
        return;
      }
      
      if (text.length > 500) {
        alert('Journal entry must be 500 characters || less.');
        return;
      }
      
      const activeVoidchiId = state.activeVoidchiId;
      if (!state.journal[activeVoidchiId]) {
        state.journal[activeVoidchiId] = [];
      }
      
      state.journal[activeVoidchiId].unshift({
        time: Date.now(),
        text: text
      });
      
      // Keep only last 20 entries per voidchi
      if (state.journal[activeVoidchiId].length > 20) {
        state.journal[activeVoidchiId].pop();
      }
      
      // Achievement: First Journal Entry
      if (!state.achievements.firstJournal) {
        state.achievements.firstJournal = true;
        addConsciousnessLog('Achievement unlocked: First Journal Entry!', 'achievement');
      }
      
      saveState();
      showVoidJournal(); // Refresh the view
      alert('Journal entry saved!');
    }
    
    function closeJournalModal() {
      journalModal.classList.remove('show');
    }

    // NEW: Update achievements display
    function updateAchievementsDisplay() {
      const achievementsBadges = document.getElementById('achievementsBadges');
      const badges = [];
      
      if (state.achievements.firstBreed) {
        badges.push('<div class="achievement-badge">üß¨ First Breed</div>');
      }
      
      if (state.achievements.trustOver80) {
        badges.push('<div class="achievement-badge">üíñ High Trust</div>');
      }
      
      if (state.achievements.fiveDayStreak) {
        badges.push('<div class="achievement-badge">üî• 5-Day Streak</div>');
      }
      
      if (state.achievements.generation3) {
        badges.push('<div class="achievement-badge premium">üëë Generation 3</div>');
      }
      
      if (state.achievements.firstJournal) {
        badges.push('<div class="achievement-badge">üìì Journal Keeper</div>');
      }
      
      achievementsBadges.innerHTML = badges.join('');
    }

    // NEW: Check for achievement milestones
    function checkAchievements() {
      const activeVoidchi = getActiveVoidchi();
      
      // Trust over 80%
      if (activeVoidchi.identity.trust >= 0.8 && !state.achievements.trustOver80) {
        state.achievements.trustOver80 = true;
        addConsciousnessLog('Achievement unlocked: High Trust!', 'achievement');
      }
      
      // 5-day streak (simplified check)
      const fiveDaysAgo = Date.now() - (5 * 24 * 60 * 60 * 1000);
      const recentInteractions = state.memory.filter(m => 
        m.voidchiId === state.activeVoidchiId && 
        m.time > fiveDaysAgo && 
        m.action !== "autonomous"
      );
      
      if (recentInteractions.length >= 10 && !state.achievements.fiveDayStreak) {
        state.achievements.fiveDayStreak = true;
        addConsciousnessLog('Achievement unlocked: 5-Day Streak!', 'achievement');
      }
    }

    // NEW: Apply cosmetic effects based on lineage and trust
    function applyCosmeticEffects() {
      const activeVoidchi = getActiveVoidchi();
      const voidchiElement = document.getElementById('voidchi');
      
      // Remove existing cosmetic classes
      voidchiElement.classList.remove('voidchi-generations-3', 'voidchi-trust-memory-low');
      
      // Generation 3+ effect
      if (activeVoidchi.identity.lineage?.generation >= 3) {
        voidchiElement.classList.add('voidchi-generations-3');
      }
      
      // Low trust memory effect
      if (activeVoidchi.identity.irreversibleTraits.trustMemory < 0.4) {
        voidchiElement.classList.add('voidchi-trust-memory-low');
      }
    }

    // Enhanced Render System
    function render() {
      const activeVoidchi = getActiveVoidchi();
      const vc = document.getElementById("voidchi");
      const moodEl = document.getElementById("mood");
      const detailEl = document.getElementById("mood-detail");
      const trustFill = document.getElementById("trust-fill");
      const attachmentEl = document.getElementById("attachment-text");
      const lastCheckEl = document.getElementById("last-check");
      const logItems = document.getElementById("log-items");
      const autoIndicator = document.getElementById("autonomous-indicator");
      const expectedCheckinEl = document.getElementById("expected-checkin");
      const patternConfidenceEl = document.getElementById("pattern-confidence");
      const voidchiName = document.getElementById("voidchiName");
      const subtitleEl = document.getElementById("subtitle");
      const voidchiSelector = document.getElementById("voidchiSelector");
      
      const patienceFill = document.getElementById("patience-fill");
      const curiosityFill = document.getElementById("curiosity-fill");
      const vigilanceFill = document.getElementById("vigilance-fill");
      const trustMemoryFill = document.getElementById("trust-memory-fill");
      const sociabilityFill = document.getElementById("sociability-fill");

      // All features are unlocked
      const count = Object.keys(state.voidchis).length;
      subtitleEl.textContent = `Your Evolving AI Companion ‚Ä¢ ${count} Voidchi${count > 1 ? 's' : ''} ‚Ä¢ Complete Edition`;

      if (Object.keys(state.voidchis).length > 1) {
        voidchiSelector.style.display = 'flex';
        voidchiSelector.innerHTML = '';
        
        Object.values(state.voidchis).forEach(voidchi => {
          const option = document.createElement('div');
          option.className = `voidchi-option ${voidchi.id === state.activeVoidchiId ? 'active' : ''}`;
          option.textContent = voidchi.identity.name;
          option.onclick = () => switchVoidchi(voidchi.id);
          voidchiSelector.appendChild(option);
        });
      } else {
        voidchiSelector.style.display = 'none';
      }

      voidchiName.textContent = activeVoidchi.identity.name;

      moodEl.textContent = "Mood: " + activeVoidchi.internal.currentMood;
      if (activeVoidchi.internal.isAutonomous) {
        moodEl.classList.add("autonomous");
        autoIndicator.classList.add("active");
      } else {
        moodEl.classList.remove("autonomous");
        autoIndicator.classList.remove("active");
      }
      
      detailEl.textContent = activeVoidchi.internal.currentMessage;

      trustFill.style.width = (activeVoidchi.identity.trust * 100).toFixed(0) + "%";
      vc.style.setProperty('--trust', activeVoidchi.identity.trust);
      
      attachmentEl.textContent = activeVoidchi.identity.attachmentStyle;

      const hoursAgo = hoursSince(activeVoidchi.internal.lastCheckin);
      lastCheckEl.textContent = hoursAgo < 1 ? "< 1h" : hoursAgo.toFixed(1) + "h";

      expectedCheckinEl.textContent = state.expectations.checkinFrequencyHours.toFixed(1) + "h";
      patternConfidenceEl.textContent = (state.expectations.patternConfidence * 100).toFixed(0) + "%";

      const traits = activeVoidchi.identity.personalityTraits;
      patienceFill.style.width = (traits.patience * 100).toFixed(0) + "%";
      curiosityFill.style.width = (traits.curiosity * 100).toFixed(0) + "%";
      vigilanceFill.style.width = (traits.vigilance * 100).toFixed(0) + "%";
      sociabilityFill.style.width = (traits.sociability * 100).toFixed(0) + "%";
      trustMemoryFill.style.width = (activeVoidchi.identity.irreversibleTraits.trustMemory * 100).toFixed(0) + "%";

      updateVoidchiExpression(activeVoidchi.internal.currentMood);

      updateIgnoredState();

      const activeVoidchiMemory = state.memory.filter(entry => entry.voidchiId === state.activeVoidchiId);
      logItems.innerHTML = activeVoidchiMemory.slice(0, 15).map(entry => {
        const t = new Date(entry.time).toLocaleTimeString();
        const className = entry.action === "autonomous" ? "log-item autonomous" : "log-item";
        return `<div class="${className}"><span>${t}</span> [${entry.mood}] ${entry.note.substring(0, 80)}</div>`;
      }).join("");

      // NEW: Update mode toggle
      document.getElementById('gentleMode').classList.toggle('active', state.settings.mode === 'gentle');
      document.getElementById('experimentalMode').classList.toggle('active', state.settings.mode === 'experimental');
      
      // NEW: Update achievements
      updateAchievementsDisplay();
      
      // NEW: Apply cosmetic effects
      applyCosmeticEffects();
      
      // NEW: Check achievements
      checkAchievements();

      updateConsciousnessDisplay();
      updateConsciousnessLogDisplay();
    }

    // Export / Import / Stats
    function exportVoidchi() {
      try {
        const raw = JSON.stringify(state);
        const encoded = btoa(unescape(encodeURIComponent(raw)));
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(encoded);
          alert("Voidchi consciousness exported to clipboard!");
        } else {
          prompt("Copy your Voidchi code:", encoded);
        }
      } catch (e) {
        alert("Export failed.");
      }
    }

    function importVoidchi() {
      const data = prompt("Paste your Voidchi code:");
      if (!data) return;
      try {
        const decoded = decodeURIComponent(escape(atob(data.trim())));
        const importedState = JSON.parse(decoded);
        
        Object.keys(importedState.voidchis).forEach(id => {
          state.voidchis[id] = importedState.voidchis[id];
        });
        
        state.activeVoidchiId = importedState.activeVoidchiId;
        state.premium = importedState.premium || state.premium;
        state.settings = importedState.settings || state.settings;
        state.achievements = importedState.achievements || state.achievements;
        state.journal = importedState.journal || state.journal;
        
        saveState();
        render();
        alert("Consciousness restored!");
      } catch (e) {
        alert("Invalid code.");
      }
    }

    function resetVoidchi() {
      if (confirm("Reset all Voidchis? All memory and learning will be erased.")) {
        localStorage.removeItem("voidchi_permamind_premium");
        location.reload();
      }
    }

    function showStats() {
      const activeVoidchi = getActiveVoidchi();
      const traits = activeVoidchi.identity.personalityTraits;
      const irreversible = activeVoidchi.identity.irreversibleTraits;
      const age = ((Date.now() - activeVoidchi.identity.birthDate) / 86400000).toFixed(1);
      const interactions = state.memory.filter(m => m.voidchiId === state.activeVoidchiId && m.action !== "autonomous").length;
      
      let statsText = `PermaMind‚Ñ¢ Statistics\n\n` +
        `Active Voidchi: ${activeVoidchi.identity.name}\n` +
        `Age: ${age} days\n` +
        `Trust: ${(activeVoidchi.identity.trust * 100).toFixed(0)}%\n` +
        `Attachment: ${activeVoidchi.identity.attachmentStyle}\n\n` +
        `Personality Evolution:\n` +
        `‚Ä¢ Patience: ${(traits.patience * 100).toFixed(0)}%\n` +
        `‚Ä¢ Curiosity: ${(traits.curiosity * 100).toFixed(0)}%\n` +
        `‚Ä¢ Vigilance: ${(traits.vigilance * 100).toFixed(0)}%\n` +
        `‚Ä¢ Sociability: ${(traits.sociability * 100).toFixed(0)}%\n` +
        `‚Ä¢ Introspection: ${(traits.introspection * 100).toFixed(0)}%\n\n` +
        `Irreversible Traits:\n` +
        `‚Ä¢ Trust Memory: ${(irreversible.trustMemory * 100).toFixed(0)}%\n` +
        `‚Ä¢ Attachment Imprint: ${(irreversible.attachmentImprint * 100).toFixed(0)}%\n` +
        `‚Ä¢ Core Expectation: ${(irreversible.coreExpectation * 100).toFixed(0)}%\n\n` +
        `Learning:\n` +
        `‚Ä¢ Expected check-in: ${state.expectations.checkinFrequencyHours.toFixed(1)}h\n` +
        `‚Ä¢ Pattern confidence: ${(state.expectations.patternConfidence * 100).toFixed(0)}%\n` +
        `‚Ä¢ Memory entries: ${state.memory.length}\n` +
        `‚Ä¢ Total interactions: ${interactions}`;
      
      if (activeVoidchi.identity.lineage) {
        statsText += `\n\nLineage:\n` +
          `‚Ä¢ Generation: ${activeVoidchi.identity.lineage.generation}\n` +
          `‚Ä¢ Parents: ${state.voidchis[activeVoidchi.identity.lineage.parent1].identity.name} & ${state.voidchis[activeVoidchi.identity.lineage.parent2].identity.name}`;
      }
      
      statsText += `\n\nComplete Edition Features:\n` +
        `‚Ä¢ Total Voidchis: ${Object.keys(state.voidchis).length}\n` +
        `‚Ä¢ Breeding Available: ${Object.keys(state.voidchis).length >= 2 ? 'Yes' : 'No'}\n` +
        `‚Ä¢ Advanced Analytics: Enabled\n` +
        `‚Ä¢ Current Mode: ${state.settings.mode === 'gentle' ? 'Gentle' : 'Experimental'}`;
      
      alert(statsText);
    }

    // PWA: Service worker registration with error handling
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        try {
          // Only register if not running from local file system
          if (window.location.protocol !== 'file:') {
            navigator.serviceWorker
              .register('/sw.js')
              .catch(err => console.log('SW registration failed (normal for local files):', err));
          }
        } catch (e) {
          console.log('Service worker registration skipped (local file)');
        }
      });
    }

    
    // Bind existing cloud id without forcing network create each load
    async function syncNowIfBound() {
      try {
        const token = getSessionToken();
        if (!token) { renderCloudStatus(); return; }
        // verify session
        const me = await apiFetch('/api/auth/me');
        cloud.authed = true;
        cloud.user = me.user || null;

        state.cloud = state.cloud || {};
        if (state.cloud.serverVoidchiId) {
          cloud.serverVoidchiId = state.cloud.serverVoidchiId;
        }

        // If not bound yet, don't auto-create unless user hits Sync
        renderCloudStatus();
        renderChat();
      } catch (e) {
        // token bad
        cloud.authed = false;
        cloud.user = null;
        renderCloudStatus();
      }
    }

    function ensureChatState() {
      const id = state.activeVoidchiId;
      state.chat = state.chat || {};
      state.chat[id] = state.chat[id] || { messages: [] };
      // cap
      if (state.chat[id].messages.length > 80) {
        state.chat[id].messages = state.chat[id].messages.slice(-80);
      }
      return state.chat[id];
    }

    function escapeHtml(s) {
      return (s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
    }

    function renderChat() {
      const scroll = document.getElementById('chatScroll');
      if (!scroll) return;
      const chat = ensureChatState();
      scroll.innerHTML = chat.messages.map(m => {
        const cls = m.role === 'user' ? 'user' : 'ai';
        const tag = m.role === 'user' ? 'You' : (getActiveVoidchi().identity.name || 'Voidchi');
        return `<div class="chat-bubble ${cls}"><div style="opacity:.65;font-size:11px;margin-bottom:2px;">${tag}</div><div>${escapeHtml(m.content)}</div></div>`;
      }).join('') || `<div class="muted" style="padding:10px 0;">No chat yet. Say hi.</div>`;
      scroll.scrollTop = scroll.scrollHeight;

      const hint = document.getElementById('chatNetHint');
      if (hint) {
        if (!getSessionToken()) hint.textContent = 'Sign in to chat across devices.';
        else if (!state.cloud || !state.cloud.serverVoidchiId) hint.textContent = 'Tap Sync to bind your companion.';
        else hint.textContent = 'Chat sync active.';
      }
    }

    async function sendChat() {
      const input = document.getElementById('chatInput');
      if (!input) return;
      const text = (input.value || '').trim();
      if (!text) return;
      input.value = '';

      const chat = ensureChatState();
      chat.messages.push({ role: 'user', content: text, t: Date.now() });
      saveState();
      renderChat();

      // If cloud not ready, respond locally using existing qualia system
      const cloudId = state.cloud && state.cloud.serverVoidchiId;
      const token = getSessionToken();
      if (!cloudId || !token) {
        const voids = computeVoids('talk');
        const qualia = resolveToQualia(voids);
        const localReply = `${qualia.message} (Local mode)`;
        chat.messages.push({ role: 'assistant', content: localReply, t: Date.now() });
        saveState();
        renderChat();
        return;
      }

      const btn = document.getElementById('chatSendBtn');
      if (btn) { btn.disabled = true; btn.textContent = '...'; }
      try {
        const resp = await apiFetch(`/api/voidchi/${encodeURIComponent(cloudId)}/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text })
        });
        // server returns {message, consciousness_level, personality_traits,...}
        const reply = resp.message || '...';
        chat.messages.push({ role: 'assistant', content: reply, t: Date.now() });

        // gently sync server traits into local
        const active = getActiveVoidchi();
        if (resp.personality_traits) {
          const st = resp.personality_traits;
          if (typeof st.curiosity === 'number') active.identity.personalityTraits.curiosity = clamp01(st.curiosity);
          if (typeof st.vigilance === 'number') active.identity.personalityTraits.vigilance = clamp01(st.vigilance);
          if (typeof st.stability === 'number') active.identity.personalityTraits.patience = clamp01(st.stability);
        }
        if (typeof resp.consciousness_level === 'number') {
          active.identity.trust = clamp01(0.35 + 0.65 * resp.consciousness_level);
        }
        state.cloud.lastSyncAt = Date.now();

        saveState();
        render();
        renderChat();
      } catch (e) {
        chat.messages.push({ role: 'assistant', content: `Cloud error: ${e.message}. Staying local.`, t: Date.now() });
        saveState();
        renderChat();
      } finally {
        if (btn) { btn.disabled = false; btn.textContent = 'Send'; }
      }
    }

    // Auth modal wiring
    const authModal = document.getElementById('authModal');
    const closeAuthModalBtn = document.getElementById('closeAuthModal');
    if (closeAuthModalBtn) closeAuthModalBtn.addEventListener('click', closeAuth);
    if (authModal) authModal.addEventListener('click', (e) => { if (e.target === authModal) closeAuth(); });

    window.openAuth = openAuth;
    window.closeAuth = closeAuth;
    window.startMagicLinkFromModal = startMagicLinkFromModal;
    window.logoutCloud = logoutCloud;
    window.syncNow = syncNow;
    window.sendChat = sendChat;


    // Initialization & Tick Loop
    function tick() {
      checkAutonomousBehavior();
      updateIgnoredState();
      consciousnessTick();
      
      const activeVoidchi = getActiveVoidchi();
      const hoursElapsed = hoursSince(activeVoidchi.internal.lastInteraction);
      activeVoidchi.internal.socialNeed = clamp01(activeVoidchi.internal.socialNeed + 0.01 * hoursElapsed);
      activeVoidchi.internal.energy = clamp01(activeVoidchi.internal.energy - 0.005 * hoursElapsed + 0.01);
      
      render();
    }

    // Initialize
    (async function init() {
      await consumeMagicLinkTokenIfPresent();
      await syncNowIfBound();
      renderCloudStatus();

      const activeVoidchi = getActiveVoidchi();
      if (!state.memory.length) {
        activeVoidchi.internal.currentMessage = "Awakening PermaMind‚Ñ¢ systems. Building your behavioral model...";
        saveState();
      } else {
        const voids = computeVoids("load");
        const primary = voids.sort((a, b) => b.magnitude - a.magnitude)[0];
        
        if (primary && primary.magnitude > 0.4) {
          const qualia = resolveToQualia(voids);
          activeVoidchi.internal.currentMood = qualia.mood;
          activeVoidchi.internal.currentMessage = "[On Return] " + qualia.message;
          updateVoidchiExpression(qualia.mood);
        }
      }
      
      if (state.memory.length < 3) {
        setTimeout(() => {
          requestNotificationPermission();
        }, 3000);
      }
      
      // Add initial consciousness log
      if (activeVoidchi.consciousnessLog.length === 0) {
        addConsciousnessLog('Complete edition activated - All features unlocked', 'system');
      }
      
      render();
      
      setInterval(tick, 30000);
    })( );
  </script>
</body>
</html>
